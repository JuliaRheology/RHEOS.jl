<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · RHEOS.jl</title><meta name="title" content="API · RHEOS.jl"/><meta property="og:title" content="API · RHEOS.jl"/><meta property="twitter:title" content="API · RHEOS.jl"/><meta name="description" content="Documentation for RHEOS.jl."/><meta property="og:description" content="Documentation for RHEOS.jl."/><meta property="twitter:description" content="Documentation for RHEOS.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="RHEOS.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">RHEOS.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../architecture/">Architecture</a></li><li><a class="tocitem" href="../fileio/">File I/O</a></li><li><a class="tocitem" href="../preprocessing/">Preprocessing</a></li><li><a class="tocitem" href="../gendata/">Generating Data</a></li><li><span class="tocitem">Fit and Predict</span><ul><li><a class="tocitem" href="../fitpredictTime/">Time data</a></li><li><a class="tocitem" href="../fitpredictFreq/">Frequency data</a></li></ul></li><li><a class="tocitem" href="../numerical/">Numerical Aspects</a></li><li><span class="tocitem">Models</span><ul><li><a class="tocitem" href="../model_elements/">Basic Elements</a></li><li><a class="tocitem" href="../model_maxwell/">Maxwell</a></li><li><a class="tocitem" href="../model_kv/">Kelvin-Voigt</a></li><li><a class="tocitem" href="../model_zener/">Zener</a></li><li><a class="tocitem" href="../model_pt/">Poynting-Thomson</a></li><li><a class="tocitem" href="../model_burgers/">Burgers</a></li><li><a class="tocitem" href="../model_create/">Create Your Model</a></li></ul></li><li><a class="tocitem" href="../examples/">Additional Examples</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Main-RHEOS-data-structures"><span>Main RHEOS data structures</span></a></li><li><a class="tocitem" href="#Moduli/compliance-functions"><span>Moduli/compliance functions</span></a></li><li><a class="tocitem" href="#Sampling-and-Filtering-Functions"><span>Sampling and Filtering Functions</span></a></li><li><a class="tocitem" href="#Fitting-and-Predicting-Functions"><span>Fitting and Predicting Functions</span></a></li><li><a class="tocitem" href="#Data-Generation-Functions"><span>Data Generation Functions</span></a></li><li><a class="tocitem" href="#Data-IO"><span>Data IO</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaRheology/RHEOS.jl/edit/master/docs/src/API.md" title="View source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h1><h2 id="Main-RHEOS-data-structures"><a class="docs-heading-anchor" href="#Main-RHEOS-data-structures">Main RHEOS data structures</a><a id="Main-RHEOS-data-structures-1"></a><a class="docs-heading-anchor-permalink" href="#Main-RHEOS-data-structures" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RHEOS.RheoTimeData"><a class="docstring-binding" href="#RHEOS.RheoTimeData"><code>RHEOS.RheoTimeData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RheoTimeData(;σ::Vector{T1}, ϵ::Vector{T2}, t::Vector{T3}) where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}</code></pre><p><code>RheoTimeData</code> struct contains stress, strain and time data.</p><p>If preferred, an instance can be generated manually by just providing the three data vectors in the right order, sampling type will be checked automatically.</p><p><strong>Fields</strong></p><ul><li><code>σ</code>: stress</li><li><code>ϵ</code>: strain</li><li><code>t</code>: time</li><li><code>log</code>: a log of struct&#39;s events, e.g. preprocessing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.RheoFreqData"><a class="docstring-binding" href="#RHEOS.RheoFreqData"><code>RHEOS.RheoFreqData</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RheoFreqData(Gp::Vector{T1}, Gpp::Vector{T2}, ω::Vector{T3}, log::OrderedDict{Any,Any}) where {T1&lt;:Real, T2&lt;:Real, T3&lt;:Real}</code></pre><p><code>RheoFreqData</code> contains storage modulus, loss modulus and frequency data.</p><p>If preferred, an instance can be generated manually by just providing the three data vectors in the right order.</p><p><strong>Fields</strong></p><ul><li><code>Gp</code>: storage modulus</li><li><code>Gpp</code>: loss modulus</li><li><code>ω</code>: frequency</li><li><code>log</code>: a log of struct&#39;s events, e.g. preprocessing</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.gettime"><a class="docstring-binding" href="#RHEOS.gettime"><code>RHEOS.gettime</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gettime(d::RheoTimeData)</code></pre><p>returns the time vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.getstress"><a class="docstring-binding" href="#RHEOS.getstress"><code>RHEOS.getstress</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getstress(d::RheoTimeData)</code></pre><p>returns the stress vector if d contains stress data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.getstrain"><a class="docstring-binding" href="#RHEOS.getstrain"><code>RHEOS.getstrain</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getstrain(d::RheoTimeData)</code></pre><p>returns the strain vector if d contains strain data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.getfreq"><a class="docstring-binding" href="#RHEOS.getfreq"><code>RHEOS.getfreq</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getfreq(d::RheoFreqData)</code></pre><p>returns the frequency ω vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.getstorage"><a class="docstring-binding" href="#RHEOS.getstorage"><code>RHEOS.getstorage</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getstorage(d::RheoFreqData)</code></pre><p>returns the storage modulus vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.getloss"><a class="docstring-binding" href="#RHEOS.getloss"><code>RHEOS.getloss</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getloss(d::RheoFreqData)</code></pre><p>returns the loss modulus vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><h2 id="Moduli/compliance-functions"><a class="docs-heading-anchor" href="#Moduli/compliance-functions">Moduli/compliance functions</a><a id="Moduli/compliance-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Moduli/compliance-functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RHEOS.RheoModelClass"><a class="docstring-binding" href="#RHEOS.RheoModelClass"><code>RHEOS.RheoModelClass</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RheoModelClass(;name::String, p::Tuple, G,J,Gp,Gpp, constraint, info, G_ramp)</code></pre><p><code>RheoModelClass</code> is a complex data structure that contains all the relevant data to  allow RHEOS to fit models and make predictions once parameters are set. RHEOS possesses already a large number of such data structures to represent common rheological models, such as Maxwell or KelvinVoigt.</p><p>Users are not expected to directly manipulate the content of a RheoModelClass object, but will  pass it to relevant functions for fitting and numerically evaluating visco-elastic moduli.</p><p>The model name and its parameters can however be printed and display on the REPL.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; Maxwell

Model name: maxwell

Free parameters: η and k

                ___
            _____| |________╱╲  ╱╲  ╱╲  ___
                _|_|          ╲╱  ╲╱  ╲╱
                  η                  k
               </code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.RheoModel"><a class="docstring-binding" href="#RHEOS.RheoModel"><code>RHEOS.RheoModel</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RheoModel(m::RheoModelClass, nt0::NamedTuple)</code></pre><p><code>RheoModel</code> represents a rheological model with set parameters. They are obtained by fitting a model to data using <code>modelfit</code>,  or by specialising the relevant RheoModelClass by prescribing its parameters. Parameters can be provided as a named tuple or keyword arguments.</p><p><code>RheoModel</code> objects can then be used to simulate the response to an arbitrary input using <code>modelpredict</code>, and access the values of the moduli functions.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; model = RheoModel(Maxwell, (k=1, η=2.))
[...]

julia&gt; model = RheoModel(Maxwell, k=1, η=2.)
[...]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.getparams"><a class="docstring-binding" href="#RHEOS.getparams"><code>RHEOS.getparams</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">getparams(m::RheoModel; unicode=true)</code></pre><p><code>getparams</code> return the list of model parameters with their values as a NamedTuple. If <code>unicode</code> is set to <code>false</code>, the unicode symbols are converted their text equivalent.</p><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; model = RheoModel(Maxwell, k=1, η=2.)
[...]

julia&gt; getparams(m)
(k = 1.0, η = 2.0)

julia&gt; getparams(m,unicode=false)
(k = 1.0, eta = 2.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.freezeparams"><a class="docstring-binding" href="#RHEOS.freezeparams"><code>RHEOS.freezeparams</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">freezeparams(m::RheoModelClass, nt0::NamedTuple)</code></pre><p>Return a new <code>RheoModelClass</code> with some of the parameters frozen to specific values</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: original <code>RheoModelClass</code></li><li><code>nt0</code>: named tuple with values for each parameter to freeze</li></ul><p><strong>Example</strong></p><pre><code class="language- hljs">julia&gt; SLS2_mod = freezeparams( SLS2, (G₀=2,η₂=3.5))
[...]

julia&gt; SLS2.G(1,[2,1,2,3,3.5])
3.8796492

julia&gt; SLS2_mod.G(1,[1,2,3])
3.8796492</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.relaxmod"><a class="docstring-binding" href="#RHEOS.relaxmod"><code>RHEOS.relaxmod</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">relaxmod(m[, t, params])</code></pre><p>provide access to the relaxation modulus (G) of a given model m. It can be used with a broad range of inputs.</p><p>When a time value is provided (or an array of time values), the function returns the corresponding value(s) of the relaxation modulus.</p><pre><code class="language-julia hljs">relaxmod(m::RheoModel, time (single value or array))

relaxmod(m::RheoModelClass, time (single value or array), parameters (array, named tupple or keyword parameters))</code></pre><p>Examples:</p><pre><code class="language-julia hljs">relaxmod(Maxwell, 1, k=1., η=1)

relaxmod(Maxwell, [1,2,3], [1,1])</code></pre><p>When no time value is provided, relaxmod returns the relaxation function itself.</p><pre><code class="language-julia hljs">relaxmod(m::RheoModel)

relaxmod(m::RheoModelClass, parameters (array, named tupple or keyword parameters))</code></pre><p>Examples:</p><pre><code class="language-julia hljs">m = RheoModel(Maxwell, k=1., η=1)
G = relaxmod(m)
G([0,1,2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.creepcomp"><a class="docstring-binding" href="#RHEOS.creepcomp"><code>RHEOS.creepcomp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">creepcomp(m[, t, params])</code></pre><p>provide access to the creep compliance (J) of a given model m. It can be used with a broad range of inputs.</p><p>When a time value is provided (or an array of time values), the function returns the corresponding value(s) of the creep compliance.</p><pre><code class="language-julia hljs">creepcomp(m::RheoModel, time (single value or array))

creepcomp(m::RheoModelClass, time (single value or array), parameters (array, named tupple or keyword parameters))</code></pre><p>Examples:</p><pre><code class="language-julia hljs">creepcomp(Maxwell, 1, k=1., η=1)

creepcomp(Maxwell, [1,2,3], [1,1])</code></pre><p>When no time value is provided, creepcomp returns the creep compliance function itself.</p><pre><code class="language-julia hljs">creepcomp(m::RheoModel)

creepcomp(m::RheoModelClass, parameters (array, named tupple or keyword parameters))</code></pre><p>Examples:</p><pre><code class="language-julia hljs">m = RheoModel(Maxwell, k=1., η=1)
J = creepcomp(m)
J([0,1,2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.storagemod"><a class="docstring-binding" href="#RHEOS.storagemod"><code>RHEOS.storagemod</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">storagemod(m[, ω, params])</code></pre><p>provide access to the storage modulus (G&#39;) of a given model m.</p><p>When a frequency value is provided (or an array of frequency values), the function returns the corresponding value(s) of the storage modulus.</p><pre><code class="language-julia hljs">storagemod(m::RheoModel, frequency (single value or array))

storagemod(m::RheoModelClass, frequency (single value or array), parameters (array, named tupple or keyword parameters))</code></pre><p>Examples:</p><pre><code class="language-julia hljs">storagemod(Maxwell, 1, k=1., η=1)

storagemod(Maxwell, [1,2,3], [1,1])</code></pre><p>When no time value is provided, storagemod returns the storage modulus function itself.</p><pre><code class="language-julia hljs">storagemod(m::RheoModel)

storagemod(m::RheoModelClass, parameters (array, named tupple or keyword parameters))</code></pre><p>Examples:</p><pre><code class="language-julia hljs">m = RheoModel(Maxwell, k=1., η=1)
Gp = storagemod(m)
Gp([0,1,2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.lossmod"><a class="docstring-binding" href="#RHEOS.lossmod"><code>RHEOS.lossmod</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lossmod(m[, ω, params])</code></pre><p>provide access to the loss modulus (G&#39;&#39;) of a given model m.</p><p>When a frequency value is provided (or an array of frequency values), the function returns the corresponding value(s) of the loss modulus.</p><pre><code class="language-julia hljs">lossmod(m::RheoModel, frequency (single value or array))

lossmod(m::RheoModelClass, frequency (single value or array), parameters (array, named tupple or keyword parameters))</code></pre><p>Examples:</p><pre><code class="language-julia hljs">lossmod(Maxwell, 1, k=1., η=1)

lossmod(Maxwell, [1,2,3], [1,1])</code></pre><p>When no time value is provided, lossmod returns the loss modulus function itself.</p><pre><code class="language-julia hljs">lossmod(m::RheoModel)

lossmod(m::RheoModelClass, parameters (array, named tupple or keyword parameters))</code></pre><p>Examples:</p><pre><code class="language-julia hljs">m = RheoModel(Maxwell, k=1., η=1)
Gpp = lossmod(m)
Gpp([0,1,2])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.dynamicmod"><a class="docstring-binding" href="#RHEOS.dynamicmod"><code>RHEOS.dynamicmod</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dynamicmod(m[, ω, params])</code></pre><p>provide access to the complex dynamic modulus (G&#39; + i G&#39;&#39;) of a given model m.</p><ul><li><p>When a frequency value is provided (or an array of frequency values), the function returns the corresponding value(s) of the complex dynamic modulus.</p><p>dynamicmod(m::RheoModel, frequency (single value or array))</p><p>dynamicmod(m::RheoModelClass, frequency (single value or array), parameters (array, named tupple or keyword parameters))</p></li></ul><p>Examples:</p><pre><code class="language-julia hljs">dynamicmod(Maxwell, 1, k=1., η=1)

dynamicmod(Maxwell, [1,2,3], [1,1])</code></pre><ul><li><p>When no time value is provided, lossmod returns the complex dynamic modulus function itself.</p><p>dynamicmod(m::RheoModel)</p><p>dynamicmod(m::RheoModelClass, parameters (array, named tupple or keyword parameters))</p></li></ul><p>Examples:</p><pre><code class="language-julia hljs">m = RheoModel(Maxwell, k=1., η=1)
Gd = dynamicmod(m)
Gd([0,1,2])</code></pre><p>Note: use abs() and angle() to get the magnitude and phase of the complex modulus.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><h2 id="Sampling-and-Filtering-Functions"><a class="docs-heading-anchor" href="#Sampling-and-Filtering-Functions">Sampling and Filtering Functions</a><a id="Sampling-and-Filtering-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Sampling-and-Filtering-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RHEOS.resample"><a class="docstring-binding" href="#RHEOS.resample"><code>RHEOS.resample</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">resample(d::RheoTimeData [, t, dt, scale )</code></pre><p>Resample the data using 1D spline extrapolation (using the Dierckx.jl package).</p><p><strong>Arguments</strong></p><ul><li><code>d</code>: data as a <code>RheoTimeData</code> struct containing time with stress and/or strain. Without additional parameters, the data is resampled to provide a uniform sampling at constant number of timepoints.</li><li><code>t</code>: an array or range that determines the timepoints where the data will be provided.</li><li><code>dt</code>: if the array <code>t</code> is not provided, the parameter <code>dt</code> will set the timestep for a uniform resampling of the data.</li><li><code>scale</code>: instead of specifying particular time points or timestep, an overall multiplicator on the sampling rate can be provided. This could down-sample (<code>scale</code>&lt;1) or upsample (<code>scale</code>&gt;1). If timesteps are non uniform, it would interpolate values accordingly.</li></ul><p><strong>Examples</strong></p><p>Assuming <code>d</code> is a <code>RheoTimeData</code> data set:</p><ul><li><code>resample(d)</code> keeps the number of sampling points the same but interpolates to set a uniform time step.</li><li><code>resample(d, t=-1:0.1:10)</code> resamples by interpolation to generate a new dataset with time points given by the range <code>t</code>.</li><li><code>resample(d, dt=0.1)</code> resamples by interpolation to generate a new dataset with uniform time step <code>dt</code>.</li><li><code>resample(d, scale=2)</code> resamples by multiplying the sampling rate by 2.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.indexweight"><a class="docstring-binding" href="#RHEOS.indexweight"><code>RHEOS.indexweight</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">indexweight(self::RheoTimeData; elperiods::Vector{K}, time_boundaries::Union{Nothing, Vector{T}} = nothing, includelast=true) where {K&lt;:Integer,T&lt;:Real}</code></pre><p>This function returns array indices (i.e. an array of integers) which can be sent to the <code>modelfit</code>, <code>modelstepfit</code> or <code>modeldiffeqfit</code> functions to provide a weighted fitting whilst maintaining constant sample-rate.</p><p>Note that <code>time_boundaries</code> must have one more entry than <code>elperiods</code> so that all sections of weighting are fully defined by beginning and end points.</p><p><code>indexweight</code> can underweight indices or overweight them. If <code>elperiods</code> in a given boundary is negative, every <code>abs(n)</code> index will be used, where <code>n</code> is the <code>elperiod</code> corresponding to a given boundary. If <code>n</code> is positive, then indicies will be duplicated <code>n</code> times such that they are given a higher weighting during the fitting procedure. If number of elements per period (<code>elperiods</code>) is <code>1</code> or <code>-1</code> it returns the original indicies for that boundary, whilst <code>0</code> is not accepted as a valid argument for <code>elperiods</code>.</p><p>The last element may or may not be included. By default the last element is forced to be included but this can be negated by providing the keyword argument <code>includelast=false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.cutting"><a class="docstring-binding" href="#RHEOS.cutting"><code>RHEOS.cutting</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cutting(self::RheoTimeData, time_on::Real, time_off::Real)</code></pre><p>Remove the data outside a specified time interval.</p><p>By specifing a time interval (<code>time_on</code>, <code>time_off</code>), a new <code>RheoTimeData</code> is returned without the data lying outside time interval.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.smooth"><a class="docstring-binding" href="#RHEOS.smooth"><code>RHEOS.smooth</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">smooth(self::RheoTimeData, τ::Real; pad::String=&quot;reflect&quot;)</code></pre><p>Smooth data using a Gaussian Kernel to time scale <code>τ</code> (approximately half power).</p><p>Smooths both <code>σ</code> and <code>ϵ</code>. Sampling frequency must be constant as it is based on FFT convolution. Essentially a low pass filter with frequencies of 1/τ being cut to approximately half power. For other pad types available see ImageFiltering documentation. As of doc writing, pad options are: <code>&quot;replicate&quot;</code> (repeat edge values to infinity), <code>&quot;circular&quot;</code> (image edges &quot;wrap around&quot;), <code>&quot;symmetric&quot;</code> (the image reflects relative to a position between pixels), <code>&quot;reflect&quot;</code> (the image reflects relative to the edge itself).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.onlytime"><a class="docstring-binding" href="#RHEOS.onlytime"><code>RHEOS.onlytime</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">onlytime(d::RheoTimeData)</code></pre><p>Return a <code>RheoTimeData</code> object with only the timeline of the parameter <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.onlystrain"><a class="docstring-binding" href="#RHEOS.onlystrain"><code>RHEOS.onlystrain</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">onlystrain(d::RheoTimeData)</code></pre><p>Return a <code>RheoTimeData</code> object with only the time and strain data of the parameter <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.onlystress"><a class="docstring-binding" href="#RHEOS.onlystress"><code>RHEOS.onlystress</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">onlystress(d::RheoTimeData)</code></pre><p>Return a <code>RheoTimeData</code> object with only the time and stress data of the parameter <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.onlyfreq"><a class="docstring-binding" href="#RHEOS.onlyfreq"><code>RHEOS.onlyfreq</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">onlyfreq(d::RheoFreqData)</code></pre><p>Return a <code>RheoFreqData</code> object with only the frequency data of the parameter <code>d</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.extract"><a class="docstring-binding" href="#RHEOS.extract"><code>RHEOS.extract</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">extract(self::Union{RheoTimeData,RheoFreqData}, type::Union{TimeDataType,FreqDataType,Integer})</code></pre><p>Extract specific fields form <code>RheoTimeData</code> or <code>RheoFreqData</code>.</p><p>Deprecated - prefer to use the functions <code>onlytime</code>, <code>onlystrain</code>, <code>onlystress</code>, and <code>onlyfreq</code>.</p><p>Extract can copy one or more fields from a given <code>RheoXData</code> variable into a new <code>RheoXData</code> one. The fields that are copied are identified by the specified type of data. If self is a <code>RheoTimeData</code>, the type that can be extracted is <code>time_only</code> (or <code>0</code>), <code>stress_only</code> (or <code>1</code>), <code>strain_only</code> (or <code>2</code>). Note that <code>strain_and_stress</code> (or <code>3</code>) is not allowed. If self is a <code>RheoFreqData</code>, the type that can be extracted is <code>freq_only</code> (or <code>0</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><h2 id="Fitting-and-Predicting-Functions"><a class="docs-heading-anchor" href="#Fitting-and-Predicting-Functions">Fitting and Predicting Functions</a><a id="Fitting-and-Predicting-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Fitting-and-Predicting-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RHEOS.modelfit"><a class="docstring-binding" href="#RHEOS.modelfit"><code>RHEOS.modelfit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">modelfit(data::RheoTimeData, model::RheoModelClass, modloading::Symbol; p0::Union{NamedTuple,Nothing} = nothing, lo::Union{NamedTuple,Nothing} = nothing, hi::Union{NamedTuple,Nothing} = nothing, verbose::Bool = false, rel_tol_x = 1e-4, diff_method=&quot;BD&quot;, weights::Union{Vector{Integer},Nothing}=nothing)</code></pre><p>Fit <code>RheologyData</code> struct to model and return a fitted model as a <code>RheologyModel</code> object. For the fitting process RHEOS relies on the optimistion package <a href="https://nlopt.readthedocs.io/en/latest/">NLopt</a>. By default, RHEOS makes use of a local derivative free algorithm, specifically the Tom Rowan&#39;s &quot;Subplex&quot; It is possible to specify which algorithm NLopt should use with the keyword parameter <code>optmethod</code>, by providing the relevant symbols as defined by NLopt.jl. Suitable options include <code>:LN_SBPLX</code> (default),  <code>:LN_COBYLA</code>, <code>:LN_BOBYQA</code> for local derivative free optimisation. Global optimisation methods are also available, but require all parameters to have lower and upper bounds set. More information about these algorithms is available on the <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/">NLopt website</a>.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: <code>RheoTimeData</code> struct containing all data</li><li><code>model</code>: <code>RheoModelClass</code> containing moduli functions and named tuple parameters</li><li><code>modloading</code>: <code>strain_imposed</code> or <code>1</code>, <code>stress_imposed</code> or <code>2</code></li><li><code>p0</code>: Initial parameters to use in fit (uses 0.5 for all parameters if not defined), provided as a named tuple</li><li><code>lo</code>: Lower bounds for parameters, provided as a named tuple</li><li><code>hi</code>: Upper bounds for parameters, provided as a named tuple</li><li><code>verbose</code>: If true, prints parameters on each optimisation iteration</li><li><code>rel_tol_x</code>: Relative tolerance of optimization as a function of input parameter values, see NLOpt docs for more details</li><li><code>rel_tol_f</code>: If given, sets a criterion based directly on changes of the function value</li><li><code>diff_method</code>: Set finite difference formula to use for derivative, currently <code>&quot;BD&quot;</code> or <code>&quot;CD&quot;</code></li><li><code>weights</code>: Vector of indices weighted according to importance, can be generated by <code>indexweight</code> function</li><li><code>optmethod</code>: optimisation algorithm used by NLOpt (passed as symbol or string) </li><li><code>opttimeout</code>: allows user to set a wall clock timeout on optimisation, used to halt a failing optimisation and return safely</li><li><code>optmaxeval</code>: allows user to set a maximum number of evaluations during optimisation, used when repeatability is required</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.modelpredict"><a class="docstring-binding" href="#RHEOS.modelpredict"><code>RHEOS.modelpredict</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">modelpredict(data::RheoTimeData, model::RheoModel; diff_method=&quot;BD&quot;)</code></pre><p>Given an incomplete data set (only either stress or strain missing) and model with values substituted into parameters (<code>RheoModel</code>), return a new dataset based on the model. If data is type of <code>stress_only</code>, then the creep modulus is used; if data type is <code>strain_only</code>, the relaxation modulus is used. A complete <code>RheoTimeData</code> of type <code>strain_and_stress</code> is returned. <code>diff_method</code> sets finite difference for calculating the derivative used in the hereditary integral and can be either backwards difference (<code>&quot;BD&quot;</code>) or central difference (<code>&quot;CD&quot;</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section><section><div><pre><code class="language-julia hljs">modelpredict(data::RheoTimeData, model::RheoModelClass; diff_method=&quot;BD&quot;, kwargs...)</code></pre><p>Variation of <code>modelpredict</code> that takes a <code>RheoModelClass</code> and parameter values rather than an already created model. This speeds up the analysis when a large number of different parameter values need to be screened, as only the relevant modulus function is created for the purpose of model prediction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.modelstepfit"><a class="docstring-binding" href="#RHEOS.modelstepfit"><code>RHEOS.modelstepfit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">modelstepfit(data::RheoTimeData, model::RheoModelClass, modloading::Union{LoadingType,Integer}; step=nothing, p0::Union{NamedTuple,Nothing} = nothing, lo::Union{NamedTuple,Nothing} = nothing, hi::Union{NamedTuple,Nothing} = nothing, verbose::Bool = false, rel_tol_x = 1e-4, weights::Union{Vector{Integer},Nothing} = nothing)</code></pre><p>Same as <code>modelfit</code> except assumes a step loading. If this assumption is appropriate for the data then fitting can be sped up greatly by use of this function. If modloading is <code>strain_imposed</code>, relaxation modulus is used, then the element in the middle of the strain is assumed to be the amplitude of the step. If modloading is <code>stress_imposed</code>, the creep modulus is used, then the middle element of the stress is assumed to be the amplitude of the step. Alternatively, it is possible to define the value of the step by defining the optional <code>step</code> parameter.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: <code>RheoTimeData</code> struct containing all data</li><li><code>model</code>: <code>RheoModelClass</code> containing moduli and parameters tuples</li><li><code>modloading</code>: <code>strain_imposed</code> for relaxation modulus, <code>stress_imposed</code> for creep modulus</li><li><code>step</code>: Optional amplitude for step</li><li><code>p0</code>: Named tuple of initial parameters to use in fit (uses 0.5 for all parameters if none given)</li><li><code>lo</code>: Named tuple of lower bounds for parameters</li><li><code>hi</code>: Named tuple of upper bounds for parameters</li><li><code>verbose</code>: If true, prints parameters on each optimisation iteration</li><li><code>rel_tol_x</code>: Relative tolerance of optimization as a function of input parameter values, see NLOpt docs for more details</li><li><code>rel_tol_f</code>: If given, overrides the default optimisation stopping criterion and sets a criterion based directly on changes of the function value</li><li><code>weights</code>: Vector of indices weighted according to importance, can be generated by <code>indexweight</code> function</li><li><code>opttimeout</code>: allows user to set a wall clock timeout on optimisation, used to halt a failing optimisation and return safely</li><li><code>optmaxeval</code>: allows user to set a maximum number of evaluations during optimisation, used when repeatability is required</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.modelsteppredict"><a class="docstring-binding" href="#RHEOS.modelsteppredict"><code>RHEOS.modelsteppredict</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">modelsteppredict(data::RheoTimeData, model::RheoModel; step_on::Real = 0.0)</code></pre><p>Same as <code>modelpredict</code> but assumes a step loading with step starting at <code>step_on</code> or closest actual value to that specified. If the loading data is variable, the magnitude in the middle of the array is used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.dynamicmodelfit"><a class="docstring-binding" href="#RHEOS.dynamicmodelfit"><code>RHEOS.dynamicmodelfit</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dynamicmodelfit(data::RheoFreqData, model::RheoModelClass; p0::Union{NamedTuple,Nothing} = nothing, lo::Union{NamedTuple,Nothing} = nothing, hi::Union{NamedTuple,Nothing} = nothing, verbose::Bool = false, rel_tol = 1e-4) where T&lt;:Real</code></pre><p>Fits model to the frequency/loss+storage moduli data.</p><p>All arguments are as described below. As this fitting procedure is fitting two functions simultaneously (the storage and loss moduli), if left untransformed the fit would tend to favour the modulus which is larger in magnitude and not fit the other modulus well. To avoid this, RHEOS offers a number of data transforms which can be used by changing <code>weights</code> argument.</p><p><strong>Arguments</strong></p><ul><li><code>data</code>: <code>RheoFreqData</code> struct containing all data</li><li><code>model</code>: <code>RheoModelClass</code> containing moduli and symbols of parameters</li><li><code>p0</code>: Initial parameters to use in fit (uses 0.5 for all parameters if none given)</li><li><code>lo</code>: Lower bounds for parameters</li><li><code>hi</code>: Upper bounds for parameters</li><li><code>verbose</code>: If true, prints parameters on each optimisation iteration</li><li><code>rel_tol_x</code>: Relative tolerance of optimization for the vector of parameters, see NLOpt docs for more details</li><li><code>rel_tol_f</code>: Relative tolerance of optimization for the objective function, see NLOpt docs for more details</li><li><code>weights</code>: Weighting mode for storage and loss modulus (<code>&quot;none&quot;</code>, <code>&quot;mean&quot;</code>, <code>&quot;log&quot;</code>, <code>&quot;local&quot;</code> or manually specified)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.dynamicmodelpredict"><a class="docstring-binding" href="#RHEOS.dynamicmodelpredict"><code>RHEOS.dynamicmodelpredict</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">dynamicmodelpredict(data::RheoFreqData, model::RheoModel)</code></pre><p>Given dynamic rheology data with only frequency and model where parameters have been substituted. Returns another <code>RheoFreqData</code> instance with the predicted <code>Gp</code> and <code>Gpp</code> based on the frequencies and model given as arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><h2 id="Data-Generation-Functions"><a class="docs-heading-anchor" href="#Data-Generation-Functions">Data Generation Functions</a><a id="Data-Generation-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Generation-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RHEOS.timeline"><a class="docstring-binding" href="#RHEOS.timeline"><code>RHEOS.timeline</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">timeline(r)</code></pre><p>Generate <code>RheoTimeData</code> struct with only the time data based on the range provided.</p><p><strong>Example:</strong></p><p><code>timeline(0:0.1:10)</code> returns a RheoTimeData with only time data, with the following series: [0.  0.1   0.2  ...  9.9  10].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section><section><div><pre><code class="language-julia hljs">timeline(;t_start::Real=0., t_end::Real, step::Real=(t_end - t_start)/250.)</code></pre><p>Generate <code>RheoTimeData</code> struct with only the time data based on the keywords provided.</p><p><strong>Arguments</strong></p><ul><li><code>t_start</code>: Starting time, typically 0</li><li><code>t_end</code>: End time</li><li><code>step</code>: Time between sample. Default set in order to provide ≈ 250 time points.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.strainfunction"><a class="docstring-binding" href="#RHEOS.strainfunction"><code>RHEOS.strainfunction</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">strainfunction(data::RheoTimeData, f::T) where T&lt;:Function
strainfunction(f::T, data::RheoTimeData) where T&lt;:Function</code></pre><p>Returns a new <code>RheoTimeData</code> with strain values calculated by applying the function <code>f</code> to the time data of the parameter data.</p><p>Normally used with a <code>RheoTimeData</code> generated using the <code>timeline</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.stressfunction"><a class="docstring-binding" href="#RHEOS.stressfunction"><code>RHEOS.stressfunction</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">stressfunction(data::RheoTimeData, f::T) where T&lt;:Function
stressfunction(f::T, data::RheoTimeData) where T&lt;:Function</code></pre><p>Returns a new <code>RheoTimeData</code> with stress values calculated by applying the function <code>f</code> to the time data of the parameter data.</p><p>Normally used with a <code>RheoTimeData</code> generated using the <code>timeline</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.hstep"><a class="docstring-binding" href="#RHEOS.hstep"><code>RHEOS.hstep</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hstep(t; offset=0., amp=1.)</code></pre><p>Step generation function for use with <code>stressfunction</code> or <code>strainfunction</code>. <code>offset</code> keyword arguent determines start of step. <code>amp</code> argument determines amplitude (height) of step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.ramp"><a class="docstring-binding" href="#RHEOS.ramp"><code>RHEOS.ramp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ramp(t; offset=0., gradient=1.)</code></pre><p>Ramp signal generation function for use with <code>stressfunction</code> or <code>strainfunction</code>. <code>offset</code> keyword argument determines start of ramp. <code>gradient</code> argument determines the linear gradient of the ramp.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.stairs"><a class="docstring-binding" href="#RHEOS.stairs"><code>RHEOS.stairs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">stairs(t; offset=0., amp=1., width=1.)</code></pre><p>Stairs signal generation function for use with <code>stressfunction</code> or <code>strainfunction</code>. Equivalent to additional steps being added every <code>width</code> seconds. <code>offset</code> keyword argument determines start of stairs signal. <code>amp</code> argument determines the height of each additional step.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.square"><a class="docstring-binding" href="#RHEOS.square"><code>RHEOS.square</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">square(t; offset=0., amp=1., period=1., width=0.5*period)</code></pre><p>Square signal generation function for use with <code>stressfunction</code> or <code>strainfunction</code>. <code>offset</code> keyword argument determines start of square signal. <code>amp</code> argument determines the height of each square pulse. <code>period</code> determines the period of one off/on section of the square wave signal. <code>width</code> determines the width of each square pulse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.sawtooth"><a class="docstring-binding" href="#RHEOS.sawtooth"><code>RHEOS.sawtooth</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sawtooth(t; offset=0., amp=1., period=1.)</code></pre><p>Sawtooth signal generation function for use with <code>stressfunction</code> or <code>strainfunction</code>. <code>offset</code> keyword argument determines start of sawtooth signal. <code>amp</code> argument determines the height of each sawtooth pulse. <code>period</code> determines the period of the sawtooth wave signal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.triangle"><a class="docstring-binding" href="#RHEOS.triangle"><code>RHEOS.triangle</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">triangle(t; offset=0., amp=1., period=1.)</code></pre><p>Triangle signal generation function for use with <code>stressfunction</code> or <code>strainfunction</code>. <code>offset</code> keyword argument determines start of triangle signal. <code>amp</code> argument determines the height of each triangle pulse. <code>period</code> determines the period of the triangle wave signal. <code>width</code> determines the width of the triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.frequencyspec"><a class="docstring-binding" href="#RHEOS.frequencyspec"><code>RHEOS.frequencyspec</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">frequencyspec(r::R; logscale=true)</code></pre><p>Generate <code>RheoFreqData</code> struct with only the frequency data distributed on a linear or log scale.</p><p><strong>Arguments</strong></p><ul><li><code>r</code>: range, e.g. 1:0.1:100</li><li><code>logscale</code>: if true, set the range in logscale, e.g. -2:0.1:20  –&gt; 10 values per decade between 10^-2 and 10^2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section><section><div><pre><code class="language-julia hljs">frequencyspec(;ω_start::Real, ω_end::Real, logstep::Real= 0.05)</code></pre><p>Generate <code>RheoFreqData</code> struct with only the frequency data distributed on a log scale.</p><p><strong>Arguments</strong></p><ul><li><code>ω_start</code>: min frequency</li><li><code>ω_end</code>: max frequency</li><li><code>logstep</code>: step between frequencies in log scale, e.g. 0.1 –&gt; 10 values per decade.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><h2 id="Data-IO"><a class="docs-heading-anchor" href="#Data-IO">Data IO</a><a id="Data-IO-1"></a><a class="docs-heading-anchor-permalink" href="#Data-IO" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="RHEOS.importcsv"><a class="docstring-binding" href="#RHEOS.importcsv"><code>RHEOS.importcsv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">importcsv(filepath::String; delimiter=&#39;,&#39;, header=false, comment = &quot;Imported from csv file&quot;, savelog = true, kwargs...)</code></pre><p>Load data from a CSV file (two/three columns, comma separated by default but delimiter can be specified in the <code>delimiter</code> keyword argument). </p><p>The function can be used to construct either a RheoTimeData instance or a RheoFreqData instance, depending on the parameters provided or column names;the function detects whether time or frequency has been included and proceeds accordingly. For oscillatory data, all three columns (Gp, Gpp, Frequency) must be provided. For regular viscoelastic data only time, or time-stress, or time-strain or time-stress-strain data can be provided.</p><p>Column can be specified in the csv file by providing their values or header name (case insensitive) as keyword parameters. </p><p><code>importcsv(&quot;filename.csv&quot;, time=1, strain=2, stress=3)</code> loads a <code>RheoTimeData</code> from a csv file with time in the first column, strain in the second, and stress in the third.</p><p><code>importcsv(&quot;filename.csv&quot;, omega=&quot;Frequency&quot;, Gp=&quot;Storage&quot;, Gpp=&quot;Loss&quot;)</code> would detect the column numbers by reading the headers on the csv file.</p><p>If no information is provided, it would try to detect columns from header names, expecting standard names. Some of the recognised keywords are <code>time</code>, <code>stress</code>, <code>strain</code>, <code>frequency</code>, <code>storage modulus</code>, <code>loss modulus</code>.</p><p>If the csv file contains headers, but it is prefered to indicate columns by their numbers rather than header strings, the keyword <code>header</code> must be set to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section><section><div><pre><code class="language-julia hljs">importcsv(filepath::String, interface::Interface; delimiter = &#39;,&#39;, header = false, comment = &quot;Imported from csv file&quot;, savelog = true, kwargs...)</code></pre><p>Import function for raw data to be transformed to stress and strain using an <code>Interface</code>. Column numbers in the csv containging the force/displacement data need to be indicated as keyword arguments using the corresponding symbols in the <code>interface</code>..</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; importcsv(&quot;myfile.csv&quot;, AFM(2e-6), t=1, d=2, f=3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article><article><details class="docstring" open="true"><summary id="RHEOS.exportcsv"><a class="docstring-binding" href="#RHEOS.exportcsv"><code>RHEOS.exportcsv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">exportcsv(self::Union{RheoTimeData, RheoFreqData}, filedir::String; delimiter=&#39;,&#39;, colorder=nothing)</code></pre><p>Export <code>RheoTimeData</code> or <code>RheoFreqData</code> type to csv format. May be useful for plotting/analysis in other software. By default, full time data will be exported with columns ordered as (t, σ, ϵ). Partial time data will be ordered as either (t, σ) or (t, ϵ). Full frequency data will be ordered as (ω, Gp, Gpp). The order of columns can be customised by passing a NamedTuple to the <code>colorder</code> arguments. For example (σ = 1, t = 3, ϵ = 2) would export the columns in the order (σ, ϵ, t). As with <code>importcsv</code>, the delimiter can be set by keyword argument.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaRheology/RHEOS.jl">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Additional Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.17.0 on <span class="colophon-date" title="Thursday 26 February 2026 14:43">Thursday 26 February 2026</span>. Using Julia version 1.12.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
