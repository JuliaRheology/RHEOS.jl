var documenterSearchIndex = {"docs":
[{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/fitpredictFreq.jl\"","category":"page"},{"location":"fitpredictFreq/#Fitting-and-Predicting-Frequency-Data","page":"Frequency data","title":"Fitting and Predicting - Frequency Data","text":"","category":"section"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"(Image: ) (Image: )","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"RHEOS can also fit models to dynamic mechanical analysis data from oscillatory tests.","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"using RHEOS","category":"page"},{"location":"fitpredictFreq/#Fitting","page":"Frequency data","title":"Fitting","text":"","category":"section"},{"location":"fitpredictFreq/#Step-1:-Loading-Experimental-Data","page":"Frequency data","title":"Step 1: Loading Experimental Data","text":"","category":"section"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"RHEOS has a convenient function to import data from CSV files (more information in File I/O section).","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"data = importcsv(\"assets/data_freq.csv\", ω_col = 1, Gp_col = 2, Gpp_col = 3)\nrheofreqdatatype(data)","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"The frequency, storage modulus and loss modulus are stored into a RheoFreqData struct.","category":"page"},{"location":"fitpredictFreq/#Step-2:-Model-Fit","page":"Frequency data","title":"Step 2: Model Fit","text":"","category":"section"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"Let's fit a Fractional Kelvin-Voigt model. The first argument is our data, the second argument tells RHEOS which model to fit (RheoModelClass). The function will return a RheoModel object, i.e. a RheoModelClass with fixed values for the parameters. The function dynamicmodelfit possesses all the additional arguments (lower and upper bounds, initial parameters, tolerance) as for the fitting of time data. Note that initial parameters, upper bounds and lower bounds can be partially specified and the rest will be filled in automatically.","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"# Lower bounds\nLo = (cₐ = 0.0, a = 0.01, cᵦ = 0.0, β = 0.01)\n# Upper bounds\nHi = (cₐ = 1e2, a = 0.99, cᵦ = 1e2, β = 0.99)\n# Initial parameters\nP0 = (cₐ = 1.0, a = 0.36, cᵦ = 1.0, β = 0.03)\n\nFractKV_model = dynamicmodelfit(data, Fract_KelvinVoigt, weights = \"log\", lo = Lo, hi = Hi, p0 = P0)","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"For the fitting process RHEOS relies on the optimistion package NLopt.jl. RHEOS makes use of a local derivative free algorithm, specifically the Tom Rowan's \"Subplex\" algorithm originally introduced in his PhD thesis at The University of Texas at Austin, 1990.","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"The storage and loss moduli can sometimes occupy different orders of magnitude. This can cause problems during fitting as the optimisation routine will weight errors at the higher orders of magnitude more strongly than those at the lower orders of magnitude. This is a more general problem often faced during multi-objective optimisation problems. RHEOS offers four rescaling options (weight):","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"The local option rescales the cost at each point by the point itself.\nThe log approach simply re-scales all the storage and loss moduli and their predicted values logarithmically before finding the error between them.\nA third option in RHEOS divides the cost at each point by the mean value of the storage and loss modulus respectively depending on which cost is being calculated. This can work well but performance is hindered if the storage or loss moduli individually vary over many orders of magnitude (mean).\nThe fourth option offered by RHEOS is simply manual weightings provided by the user for each modulus (manual).","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"In the first two cases, the benefit arises from the fact that the optimisation weighting is rebalanced in favour of smaller values. The logarithmic rescaling method seems to work particularly well but runs into problems if the storage or loss moduli are exactly 0 at any frequency, this is due to the negative singularity of the logarithmic function for the 0 argument. 0 arguments can also cause problems using the local option due to division by 0.","category":"page"},{"location":"fitpredictFreq/#Predicting","page":"Frequency data","title":"Predicting","text":"","category":"section"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"RHEOS allows the user to simulate the frequency response of a model (with defined parameters, RheoModel struct) to an imposed loading.","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"Given an incomplete data set (frequency only) and model with values substituted into parameters (RheoModel), return a new \"complete\" dataset based on the model with the simulated missing variable (storage and loss).","category":"page"},{"location":"fitpredictFreq/#Assessing-the-Quality-of-Fit","page":"Frequency data","title":"Assessing the Quality of Fit","text":"","category":"section"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"The ability of predicting model's response is first exploited to assess the quality of the fits above. The incomplete RheoFreqData variable is defined by extracting the frequency from the original data or by defining a new frequency vector.","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"data_ext = onlyfreq(data)\n# Alternatively, a RheoFreqData with only frequency data can be generated as\n# data_ext = frequencyspec(ω_start = 1.0e-2, ω_end = 1.0e2, logstep = 0.1)\n\nrheofreqdatatype(data_ext)","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"For the prediction, RHEOS' function dynamicmodelpredict requires the incomplete data set and a model with fixed parameters (RheoModel). For the assessment of the fitting quality the RheoModel is the output of the fitting function.","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"fractKV_predict = dynamicmodelpredict(data_ext, FractKV_model)\n\n# Now we can plot data and model together for comparison\nusing PyPlot\nfig, ax = subplots(1, 1, figsize = (7, 5))\nax.loglog(data.ω, data.Gp, \"o\", markersize = 5, color = \"blue\")\nax.loglog(data.ω, data.Gpp, \"o\", markersize = 5, color = \"red\")\nax.loglog(fractKV_predict.ω, fractKV_predict.Gp, \"--\", color = \"blue\")\nax.loglog(fractKV_predict.ω, fractKV_predict.Gpp, \"--\", color = \"red\")\nax.set_xlabel(\"Frequency\")\nax.set_ylabel(\"Storage and Loss moduli\")\nfig #hide","category":"page"},{"location":"fitpredictFreq/#Simulate-Different-Model-Behaviours","page":"Frequency data","title":"Simulate Different Model Behaviours","text":"","category":"section"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"The ability of predicting model's response can be exploited to simulate the behaviour of the model to other external loading conditions. For example, we will explore the response of the fitted model to a creep experiment.","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"First we need to define an incomplete RheoTimeData struct, which can be achieved via the data generation functions provided in RHEOS (see section Generating Data).","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"# Define timeline\ndσ = timeline(t_end = 10)\n# and a step in stress\ndσ = stressfunction(dσ, hstep())\n\n# we can now predict the creep response of the Maxwell model\nFractKV_creepPredict = modelsteppredict(dσ, FractKV_model)\n# Visualisation of the simulated response\nfig, ax = subplots(1, 1, figsize = (7, 5))\nax.plot(FractKV_creepPredict.t, FractKV_creepPredict.ϵ)\nax.set_xlabel(\"Time\")\nax.set_ylabel(\"Strain\")\nfig #hide","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"Reference frequency data: Deng, Linhong, et al. \"Fast and slow dynamics of the cytoskeleton.\" Nature materials 5.8 (2006): 636.","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"","category":"page"},{"location":"fitpredictFreq/","page":"Frequency data","title":"Frequency data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/preprocessing.jl\"","category":"page"},{"location":"preprocessing/#Preprocessing-of-Data","page":"Preprocessing","title":"Preprocessing of Data","text":"","category":"section"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"(Image: ) (Image: )","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"RHEOS offers several functions for sampling and filtering data; this page is intended to be a brief tutorial of their use. For detailed descriptions of functions and their optional arguments, see the API section.","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"using RHEOS\nusing PyPlot","category":"page"},{"location":"preprocessing/#Upsampling-and-Downsampling","page":"Preprocessing","title":"Upsampling and Downsampling","text":"","category":"section"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"We generate a simple sinusoid with constant sampling rate (more details about data generation are discussed in the Generating Data section).","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"# Generate a sinusoidal data set\nfoo = timeline(t_start = 0, t_end = 10, step = 0.4)\nfoo = strainfunction(foo, t -> sin(t))\nfig, ax = subplots(1, 1, figsize = (5, 5))\nax.plot(foo.t, foo.ϵ, \"--\", marker = \"o\", markersize = 8, color = \"blue\")\nfig #hide","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"To downsample the full data set , the function resample is used with a scale argument less than 1. Similarly, to increase the sample rate, the scale argument should be greater than 1.","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"note: Note\nWhen scaling, the argument can be an integer, floating point, or rational type. The function contains greater functionality and versatility than shown here. See the resample docstring for more information.","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"# Downsample\nfoo_dsamp = resample(foo, scale = 1//2)\n# Upsample\nfoo_usamp = resample(foo, scale = 2)\n\n# Plotting\nfig, ax = subplots(1, 2, figsize = (10, 5))\nax[1].set_title(\"Downsampling\")\nax[1].plot(foo.t, foo.ϵ, \"--\", marker = \"o\", markersize = 8, color = \"blue\")\nax[1].plot(foo_dsamp.t, foo_dsamp.ϵ, \"--\", marker = \"x\", markersize = 10, markeredgewidth = 2, color = \"orange\")\nax[2].set_title(\"Upsampling\")\nax[2].plot(foo.t, foo.ϵ, \"--\", marker = \"o\", markersize = 8, color = \"blue\")\nax[2].plot(foo_usamp.t, foo_usamp.ϵ, \"--\", marker = \"x\", markersize = 10, markeredgewidth = 2, color = \"orange\")\nfig #hide","category":"page"},{"location":"preprocessing/#Cutting","page":"Preprocessing","title":"Cutting","text":"","category":"section"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"RHEOS provides a dedicated function, cutting, to remove the data outside a specified time interval.","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"foo_cut = cutting(foo, 2.0, 8.0)\n\n# Plotting\nfig, ax = subplots(1, 1, figsize = (5, 5))\nax.plot(foo.t, foo.ϵ, \"--\", marker = \"o\", markersize = 8, color = \"blue\")\nax.plot(foo_cut.t, foo_cut.ϵ, \"--\", marker = \"x\", markersize = 10, markeredgewidth = 2, color = \"orange\")\nfig #hide","category":"page"},{"location":"preprocessing/#Smoothing","page":"Preprocessing","title":"Smoothing","text":"","category":"section"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"Lastly, RHEOS provides a smoothing function, smooth. The first argument is the data to smooth and the second argument is the (very) approximate time scale of smoothing. (It uses Gaussian smoothing and can be thought of as a low pass filter for information occuring on time scales shorter than the 2nd argument). The padding can be changed using a keyword argument if desired, see API and ImageFiltering.jl Documentation for more details.","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"foo_s = timeline(t_start = 0, t_end = 10, step = 0.02)\nfoo_s = strainfunction(foo_s, t -> 3*sin(t))\nnoise = strainfunction(foo_s, t -> rand())\n\nfoo_noisy = foo_s + noise\nfoo_smooth = smooth(foo_noisy, 1)\n\nfig, ax = subplots(1, 1, figsize = (5, 5))\nax.plot(foo_noisy.t, foo_noisy.ϵ, color = \"blue\")\nax.plot(foo_smooth.t, foo_smooth.ϵ, color = \"orange\")\nfig #hide","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"","category":"page"},{"location":"preprocessing/","page":"Preprocessing","title":"Preprocessing","text":"This page was generated using Literate.jl.","category":"page"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/gendata.jl\"","category":"page"},{"location":"gendata/#Generating-Data","page":"Generating Data","title":"Generating Data","text":"","category":"section"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"(Image: ) (Image: )","category":"page"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"RHEOS has several convenience functions for generating arbitrarily complex loading patterns. These may be particularly useful for investigating the responses of viscoelastic models that users may be unfamiliar with.","category":"page"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"using RHEOS\nusing PyPlot","category":"page"},{"location":"gendata/#Step-1:-Generate-Timeline","page":"Generating Data","title":"Step 1: Generate Timeline","text":"","category":"section"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"The first step requires the generation of a RheoTimeData struct with only the time data. This is achieved with the timeline function. If no parameter is specified, it generates a time data from t_start = 0 to t_end = 10, with a default time step of (t_start-t_end)/250 = 0.04.","category":"page"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"datat = timeline(t_start = 0, t_end = 20.0, step = 0.02)\nrheotimedatatype(datat)","category":"page"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"note: Note\nThe same functionality is provided to generate a frequency spectrum by using frequencyspec (see an example of its usage in the Fitting and Predicting - Frequency data section).","category":"page"},{"location":"gendata/#Step-2:-Generate-Stress-or-Strain-Data","page":"Generating Data","title":"Step 2: Generate Stress or Strain Data","text":"","category":"section"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"The user can decide either to generate strain data (strainfunction) or stress data (stressfunction). Both functions require a RheoTimeData with time data defined and a function that takes the time as an input to generate the desired set of data. Both function return a new RheoTimeData struct with time data and either stress or strain data. Below is an example.","category":"page"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"# calculates strain data by applying a function of time\ndsin = strainfunction(datat, t -> sin(2*t))\n\nfig, ax = subplots(1, 1, figsize = (8, 2))\nplot(dsin.t, dsin.ϵ)\nrheotimedatatype(dsin)\nfig #hide","category":"page"},{"location":"gendata/#Pre-defined-Functions","page":"Generating Data","title":"Pre-defined Functions","text":"","category":"section"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"RHEOS provides some functions that can be directly applied to a timeline. Below is the complete list with examples. Note that if the keyword arguments for the functions are not defined, default parameters are used (see the API section). In the examples below the strain data is generated, the same can be applied to the stress by replacing strainfunction with stressfunction.","category":"page"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"fig, ax = subplots(2, 3, figsize = (14, 7))\n\n# Step generation\ndstep = strainfunction(datat, hstep(offset = 5.0, amp = 5))\n    # Plotting\n    ax[1, 1].plot(dstep.t, dstep.ϵ)\n    ax[1, 1].set_ylim(bottom = -0.1, top = 5.4)\n    ax[1, 1].set_title(\"Step\")\n\n# Ramp generation\ndramp = strainfunction(datat, ramp(offset = 2.0, gradient = 0.8))\n    ax[1, 2].plot(dramp.t, dramp.ϵ)\n    ax[1, 2].set_ylim(bottom = -0.1)\n    ax[1, 2].set_title(\"Ramp\")\n\n# Stairs generation\ndstairs = strainfunction(datat, stairs(offset = 5.0, amp = 0.1, width = 1))\n    ax[1, 3].plot(dstairs.t, dstairs.ϵ)\n    ax[1, 3].set_ylim(bottom = -0.1)\n    ax[1, 3].set_title(\"Stairs\")\n\n# Square generation\ndsquare = strainfunction(datat, square(offset = 5.0, amp = 0.5, period = 4, width = 1))\n    ax[2, 1].plot(dsquare.t, dsquare.ϵ)\n    ax[2, 1].set_ylim(bottom = -0.05, top = 0.6)\n    ax[2, 1].set_title(\"Square\")\n\n# Sawtooth generation\ndsawtooth = strainfunction(datat, sawtooth(offset = 5.0, amp = 2, period = 5))\n    ax[2, 2].plot(dsawtooth.t, dsawtooth.ϵ)\n    ax[2, 2].set_ylim(bottom = -0.1, top = 2.2)\n    ax[2, 2].set_title(\"Sawtooth\")\n\n# Triangle generation\ndtriangle = strainfunction(datat, triangle(offset = 4.0, amp = 1, period = 4))\n    ax[2, 3].plot(dtriangle.t, dtriangle.ϵ)\n    ax[2, 3].set_ylim(bottom = -0.1, top = 1.2)\n    ax[2, 3].set_title(\"Tringle\")\n\nfig #hide","category":"page"},{"location":"gendata/#More-Complex-Patterns","page":"Generating Data","title":"More Complex Patterns","text":"","category":"section"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"More complicated patterns can be generated by making use of the possibility to add, subtract, multiply RheoTimeData structs. Note that addition and subtraction can be performed only if the data have the same sample rate.","category":"page"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"fig, ax = subplots(1, 3,figsize = (14, 4))\n\n# Ramp & hold\ndhold = dramp - strainfunction(datat, ramp(offset = 5.0, gradient = 0.8))\n    ax[2].plot(dhold.t, dhold.ϵ)\n    ax[2].set_ylim(bottom = -0.1, top = 2.8)\n    ax[2].set_title(\"Ramp & hold\")\n\n# Step with oscillatory loading\ndoscil = dstep + dsquare\n    ax[1].plot(doscil.t, doscil.ϵ)\n    ax[1].set_ylim(bottom = -0.5, top = 6)\nax[1].set_title(\"Oscillations\")\n\n# Ramp & hold & oscillation\ndcomplex = dhold + dsquare\n    ax[3].plot(dcomplex.t, dcomplex.ϵ)\n    ax[3].set_ylim(bottom = -0.1, top = 3.2)\n    ax[3].set_title(\"Ramp & hold & oscillations\")\n\nfig #hide","category":"page"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"","category":"page"},{"location":"gendata/","page":"Generating Data","title":"Generating Data","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/model_elements.jl\"","category":"page"},{"location":"model_elements/#Springpot","page":"Basic Elements","title":"Springpot","text":"","category":"section"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"(Image: ) (Image: )","category":"page"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"using RHEOS\n# include a helper function for plotting\ninclude(\"assets/plothelper.jl\");\nnothing #hide","category":"page"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"By typing the name of the model, it is possible to visualise its graphical representation and its parameters.","category":"page"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"Springpot","category":"page"},{"location":"model_elements/#Constitutive-Equation","page":"Basic Elements","title":"Constitutive Equation","text":"","category":"section"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"sigma(t) = c_beta fracd^beta epsilon(t)dt^beta","category":"page"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"textfor  0 leq beta leq 1","category":"page"},{"location":"model_elements/#Relaxation-Modulus","page":"Basic Elements","title":"Relaxation Modulus","text":"","category":"section"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"G(t) = fracc_beta Gamma(1-beta) t^-beta","category":"page"},{"location":"model_elements/#Creep-Modulus","page":"Basic Elements","title":"Creep Modulus","text":"","category":"section"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"J(t) = frac1c_beta Gamma(1+beta)t^beta","category":"page"},{"location":"model_elements/#Storage-Modulus","page":"Basic Elements","title":"Storage Modulus","text":"","category":"section"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"G^prime(omega) = c_beta omega^beta cos(fracpi2beta)","category":"page"},{"location":"model_elements/#Loss-Modulus","page":"Basic Elements","title":"Loss Modulus","text":"","category":"section"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"G^primeprime(omega) = c_beta omega^beta sin(fracpi2beta)","category":"page"},{"location":"model_elements/#Spring","page":"Basic Elements","title":"Spring","text":"","category":"section"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"When β = 0 the springpot specialises to a spring.","category":"page"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"Spring","category":"page"},{"location":"model_elements/#Dashpot","page":"Basic Elements","title":"Dashpot","text":"","category":"section"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"When β = 1 the springpot specialises to a dashpot.","category":"page"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"Dashpot","category":"page"},{"location":"model_elements/#Qualitative-Behaviours-of-the-Moduli","page":"Basic Elements","title":"Qualitative Behaviours of the Moduli","text":"","category":"section"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"models = Vector{RheoModel}()\n\n# Spring\npush!(models, RheoModel(Spring, k = 1.0))\n\n# plot moduli for varying β\nfor beta in [0.2, 0.5, 0.8]\n\n    push!(models, RheoModel(Springpot, cᵦ = 1.0, β = beta))\n\nend\n\n# Dashpot\npush!(models, RheoModel(Dashpot, η = 1.0))\n\nplotmodel(models, ymaxG = 2.0)","category":"page"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"","category":"page"},{"location":"model_elements/","page":"Basic Elements","title":"Basic Elements","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/model_kv.jl\"","category":"page"},{"location":"model_kv/#Fractional-Kelvin-Voigt","page":"Kelvin-Voigt","title":"Fractional Kelvin-Voigt","text":"","category":"section"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"(Image: ) (Image: )","category":"page"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"using RHEOS\n# include a helper function for plotting\ninclude(\"assets/plothelper.jl\");\nnothing #hide","category":"page"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"Fract_KelvinVoigt","category":"page"},{"location":"model_kv/#Constitutive-Equation","page":"Kelvin-Voigt","title":"Constitutive Equation","text":"","category":"section"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"sigma(t) = c_alpha fracd^alpha epsilon(t)dt^alpha+ c_beta fracd^beta epsilon(t)dt^beta","category":"page"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"textfor  0 leq beta leq alpha leq 1","category":"page"},{"location":"model_kv/#Relaxation-Modulus","page":"Kelvin-Voigt","title":"Relaxation Modulus","text":"","category":"section"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"G(t) =fracc_alpha Gamma(1-alpha) t^-alpha+fracc_beta Gamma(1-beta) t^-beta","category":"page"},{"location":"model_kv/#Creep-Modulus","page":"Kelvin-Voigt","title":"Creep Modulus","text":"","category":"section"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"J(t) = fract^alphac_alpha E_alpha-beta1+alphaleft(-fracc_betac_alpha t^alpha-betaright)","category":"page"},{"location":"model_kv/#Storage-Modulus","page":"Kelvin-Voigt","title":"Storage Modulus","text":"","category":"section"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"G^prime(omega) = c_alpha omega^alpha cosleft(alpha fracpi2right) + c_beta omega^beta cos left( beta fracpi2right)","category":"page"},{"location":"model_kv/#Loss-Modulus","page":"Kelvin-Voigt","title":"Loss Modulus","text":"","category":"section"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"G^primeprime(omega) = c_alpha omega^alpha sinleft(alpha fracpi2right) + c_beta omega^beta sin left( beta fracpi2right)","category":"page"},{"location":"model_kv/#Fractional-(Spring)-Kelvin-Voigt","page":"Kelvin-Voigt","title":"Fractional (Spring) Kelvin-Voigt","text":"","category":"section"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"FractS_KelvinVoigt","category":"page"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying α\nfor alpha in [0.1, 0.3, 0.5, 0.7, 0.9]\n\n    push!(models, RheoModel(FractS_KelvinVoigt, (cₐ = 1.0, a = alpha, k = 1.0)))\n\nend\n\nplotmodel(models, ymaxG = 5.0)","category":"page"},{"location":"model_kv/#Fractional-(Dashpot)-Kelvin-Voigt","page":"Kelvin-Voigt","title":"Fractional (Dashpot) Kelvin-Voigt","text":"","category":"section"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"FractD_KelvinVoigt","category":"page"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying β\nfor beta in [0.1, 0.3, 0.5, 0.7, 0.9]\n\n    push!(models, RheoModel(FractD_KelvinVoigt, (η = 10, cᵦ= 1.0, β = beta)))\n\nend\n\nplotmodel(models, ymaxG = 3.0)","category":"page"},{"location":"model_kv/#Kelvin-Voigt","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"","category":"section"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"KelvinVoigt","category":"page"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying k\nfor η in [0.1, 1.0, 5.0]\n\n    push!(models, RheoModel(KelvinVoigt, (η = η, k = 1)))\n\nend\n\nplotmodel(models)","category":"page"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"","category":"page"},{"location":"model_kv/","page":"Kelvin-Voigt","title":"Kelvin-Voigt","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/model_pt.jl\"","category":"page"},{"location":"model_pt/#Fractional-Poynting-Thomson","page":"Poynting-Thomson","title":"Fractional Poynting-Thomson","text":"","category":"section"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"(Image: ) (Image: )","category":"page"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"using RHEOS\n# include a helper function for plotting\ninclude(\"assets/plothelper.jl\");\nnothing #hide","category":"page"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"Fract_PT","category":"page"},{"location":"model_pt/#Constitutive-Equation","page":"Poynting-Thomson","title":"Constitutive Equation","text":"","category":"section"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"sigma(t) + fracc_alphac_gamma fracd^alpha-gamma sigma(t)dt^alpha-gamma+ fracc_betac_gamma fracd^beta-gamma sigma(t)dt^beta-gamma= c_alpha fracd^alpha epsilon(t)dt^alpha + c_beta fracd^beta epsilon(t)dt^beta","category":"page"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"textfor  0 leq beta leq alpha leq 1","category":"page"},{"location":"model_pt/#Relaxation-Modulus","page":"Poynting-Thomson","title":"Relaxation Modulus","text":"","category":"section"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"tildeG(s) = frac1sfracc_gamma s^gamma cdot leftc_alpha s^alpha + c_beta s^betarightc_gamma s^gamma+c_alpha s^alpha+c_beta s^beta","category":"page"},{"location":"model_pt/#Creep-Modulus","page":"Poynting-Thomson","title":"Creep Modulus","text":"","category":"section"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"J(t)= fract^alphac_alpha E_alpha-beta1+alphaleft(-fracc_betac_alpha t^alpha-betaright) + frac1c_gamma Gamma(1+gamma)t^gamma","category":"page"},{"location":"model_pt/#Storage-Modulus","page":"Poynting-Thomson","title":"Storage Modulus","text":"","category":"section"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"G^prime(omega) = fracc_gamma omega^gamma cosleft(gamma fracpi2right) leftleft(c_alpha omega^alpharight)^2+left(c_beta omega^betaright)^2 right+left(c_gamma omega^gammaright)^2 leftc_alpha omega^alpha cosleft(alpha fracpi2right)+c_beta omega^beta cosleft(beta fracpi2right) right + c_alpha omega^alpha cdot c_betaomega^beta cdot c_gamma omega^gamma leftcosleft((alpha-beta-gamma) fracpi2right)+cosleft((beta-alpha-gamma) fracpi2right) rightleft(c_alpha omega^alpharight)^2+left(c_beta omega^betaright)^2+left(c_gamma omega^gammaright)^2+2c_alpha omega^alpha cdot c_beta omega^beta cos((alpha-beta)fracpi2)+2c_alpha omega^alpha cdot c_gamma omega^gamma cos((alpha-gamma)fracpi2)+2c_beta omega^beta cdot c_gamma omega^gamma cos((beta-gamma)fracpi2)","category":"page"},{"location":"model_pt/#Loss-Modulus","page":"Poynting-Thomson","title":"Loss Modulus","text":"","category":"section"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"G^primeprime(omega) = fracc_gamma omega^gamma sinleft(gamma fracpi2right) leftleft(c_alpha omega^alpharight)^2+left(c_beta omega^betaright)^2 right+left(c_gamma omega^gammaright)^2 leftc_alpha omega^alpha sinleft(alpha fracpi2right)+c_beta omega^beta sinleft(beta fracpi2right) right + c_alpha omega^alpha cdot c_betaomega^beta cdot c_gamma omega^gamma leftsinleft((alpha-beta-gamma) fracpi2right)+sinleft((beta-alpha-gamma) fracpi2right) rightleft(c_alpha omega^alpharight)^2+left(c_beta omega^betaright)^2+left(c_gamma omega^gammaright)^2+2c_alpha omega^alpha cdot c_beta omega^beta cos((alpha-beta)fracpi2)+2c_alpha omega^alpha cdot c_gamma omega^gamma cos((alpha-gamma)fracpi2)+2c_beta omega^beta cdot c_gamma omega^gamma cos((beta-gamma)fracpi2)","category":"page"},{"location":"model_pt/#Fractional-SLS-(PT)","page":"Poynting-Thomson","title":"Fractional SLS (PT)","text":"","category":"section"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"FractSLS_PT","category":"page"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying α\nfor alpha in [0.1, 0.25, 0.5, 0.74, 0.9]\n\n    push!(models, RheoModel(FractSLS_PT, (cₐ = 1, a = alpha, kᵦ = 1, kᵧ = 1)))\n\nend\n\nplotmodel(models)","category":"page"},{"location":"model_pt/#Fractional-Jeffreys-(PT)","page":"Poynting-Thomson","title":"Fractional Jeffreys (PT)","text":"","category":"section"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"FractJeffreys_PT","category":"page"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying β\nfor beta in [0.1, 0.25, 0.5, 0.74, 0.9]\n\n    push!(models, RheoModel(FractJeffreys_PT, (ηₐ = 1, cᵦ = 1, β = beta, ηᵧ = 1)))\n\nend\n\nplotmodel(models, ymaxG = 0.5)","category":"page"},{"location":"model_pt/#Standard-Linear-Solid-(PT)","page":"Poynting-Thomson","title":"Standard Linear Solid (PT)","text":"","category":"section"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"SLS_PT","category":"page"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying kᵦ\nfor k in [1.0, 3.0, 5.0]\n\n    push!(models, RheoModel(SLS_PT, (η = 1, kᵦ = k, kᵧ = 1)))\n\nend\n\nplotmodel(models)","category":"page"},{"location":"model_pt/#Jeffreys-(Zener)","page":"Poynting-Thomson","title":"Jeffreys (Zener)","text":"","category":"section"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"Jeffreys_PT","category":"page"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying ηₐ\nfor eta in [1.0, 5.0, 8.0]\n\n    push!(models, RheoModel(Jeffreys_PT, (ηₐ = eta, k = 3, ηᵧ = 1)))\n\nend\n\nplotmodel(models)","category":"page"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"","category":"page"},{"location":"model_pt/","page":"Poynting-Thomson","title":"Poynting-Thomson","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/model_burgers.jl\"","category":"page"},{"location":"model_burgers/#Burgers-(Liquid)","page":"Burgers","title":"Burgers (Liquid)","text":"","category":"section"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"(Image: ) (Image: )","category":"page"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"using RHEOS\n# include a helper function for plotting\ninclude(\"assets/plothelper.jl\");\nnothing #hide","category":"page"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"BurgersLiquid","category":"page"},{"location":"model_burgers/#Constitutive-Equation","page":"Burgers","title":"Constitutive Equation","text":"","category":"section"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"sigma(t) + p_1 fracd sigma(t)dt + p_2  fracd^2 sigma(t)dt^2 = q_1  fracd epsilon(t)dt + q_2  fracd^2 epsilon(t)dt^2","category":"page"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"textwhere  p_1 = fraceta_1k_1+fraceta_1k_2+fraceta_1k_2text  p_2 = fraceta_1 eta_2k_1 k_2text  q_1 =  eta_1  textand  q_2 = fraceta_1 eta_2k_2","category":"page"},{"location":"model_burgers/#Relaxation-Modulus","page":"Burgers","title":"Relaxation Modulus","text":"","category":"section"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"G(t) = left left(q_1 - q_2 r_1right) e^-r_1 t  - left(q_1 - q_2 r_2right) e^-r_2 t rightA","category":"page"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"textwhere  r_1 = (p_1-A)2p_2 text  r_2 = (p_1 +A) 2p_2 text and  A = sqrtp_1^2 - 4p_2","category":"page"},{"location":"model_burgers/#Creep-Modulus","page":"Burgers","title":"Creep Modulus","text":"","category":"section"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"J(t) = frac1k_1 + fracteta_1 + frac1k_2 left(1-e^-k_2 teta_2right)","category":"page"},{"location":"model_burgers/#Storage-Modulus","page":"Burgers","title":"Storage Modulus","text":"","category":"section"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"G^prime(omega) = fracp_1 q_1 omega^2 - q_2 omega^2 (1-p_2 omega^2)p_1^2 omega^2 + (1-p_2 omega^2)^2","category":"page"},{"location":"model_burgers/#Loss-Modulus","page":"Burgers","title":"Loss Modulus","text":"","category":"section"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"G^prime prime(omega) = fracp_1 q_2 omega^3 + q_1 omega (1-p_2 omega^2)p_1^2 omega^2 + (1-p_2 omega^2)^2","category":"page"},{"location":"model_burgers/#Qualitative-Behaviours-of-the-Moduli","page":"Burgers","title":"Qualitative Behaviours of the Moduli","text":"","category":"section"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying k₁\nfor k in [0.5, 1.0, 2.0]\n\n    push!(models, RheoModel(BurgersLiquid, (η₁ = 1, k₁ = k, η₂ = 1, k₂ = 1)))\n\nend\n\nplotmodel(models)","category":"page"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"Reference: Findley, William N., and Francis A. Davis. Creep and relaxation of nonlinear viscoelastic materials. Courier Corporation, 2013.","category":"page"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"","category":"page"},{"location":"model_burgers/","page":"Burgers","title":"Burgers","text":"This page was generated using Literate.jl.","category":"page"},{"location":"architecture/#Architecture","page":"Architecture","title":"Architecture","text":"","category":"section"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/edit/master/docs/src/architecture.md\"","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"RHEOS is built around four main data types:","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"RheoTimeData: Contains time (t), stress (σ), strain (ϵ) data\nRheoFreqData: Contains frequency (ω), storage (Gp) and loss (Gpp) moduli\nRheoModelClass: Contains the model's name, parameters, and the expressions of relaxation (G), creep (J), storage (Gp) and loss (Gpp) moduli as functions of the model parameters\nRheoModel: Similar to RheoModelClass, but actual numbers are substituted (hard-coded) into the expressions for relaxation, creep, storage and loss moduli.","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"A common RHEOS workflow is illustrated in the figure below. Experimental time-domain viscoelastic data is fitted to a viscoelastic model. This model (with the fitted parameters) is then used to make a prediction of the behaviour under the fitted loading conditions so that its accuracy can be qualitatively assessed. Similarly, the fitted model can be used to simulate the behaviour of the same material under any loading conditions (different from the fitted ones).","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"(Image: High level schematic of a fitting and prediction workflow from experimental data.)","category":"page"},{"location":"architecture/","page":"Architecture","title":"Architecture","text":"So, having seen the figure above we can now think about our rheology data analysis workflow with reference to RHEOS' types and functions. Experimental data are imported into a RheoTimeData struct (or RheoFreqData for dynamic experimental data). This is then fitted to a RheoModelClass, which is the model struct used when the model's parameters are not fixed. The output of this process is a RheoModel (which is a RheoModelClass in which the parameters have been fixed to specific values). In the prediction step, the fitted RheoModel is combined with partial data (RheoTimeData with time and either only stress or strain) and fills in the missing data column, resulting in a complete data set (complete RheoTimeData).","category":"page"},{"location":"model_create/","page":"Create Your Model","title":"Create Your Model","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/model_create.jl\"","category":"page"},{"location":"model_create/#Create-Your-Model","page":"Create Your Model","title":"Create Your Model","text":"","category":"section"},{"location":"model_create/","page":"Create Your Model","title":"Create Your Model","text":"(Image: ) (Image: )","category":"page"},{"location":"model_create/","page":"Create Your Model","title":"Create Your Model","text":"RHEOS provide an extensive model library (see Models section). However, if you would like to use a model that has not already been implemented in RHEOS, you can quickly define your own model as described below. Note that currently RHEOS can only handle linear viscoelastic models. Therefore, any added model must satisfy this condition.","category":"page"},{"location":"model_create/","page":"Create Your Model","title":"Create Your Model","text":"The RheoModelClass constructor does not need to contain all moduli functions, depending on what variables are fitted and predicted down the line (relaxation modulus G for stress, creep function J for strain, and complex moduli Gp and Gpp for frequency domain data). As an example, we will assume that only the relaxation modulus is known.","category":"page"},{"location":"model_create/","page":"Create Your Model","title":"Create Your Model","text":"using RHEOS\nusing PyPlot","category":"page"},{"location":"model_create/","page":"Create Your Model","title":"Create Your Model","text":"PowerLawEmpirical =  RheoModelClass(\n                        # Model name\n                        name = \"power_empirical\",\n                        # Model parameters,\n                        p = (:A, :α),\n                        # Relaxation modulus\n                        G = quote\n                                A*t^(-α)\n                            end,\n                        # Network\n                        info = \"Empirical model\"\n                        )","category":"page"},{"location":"model_create/","page":"Create Your Model","title":"Create Your Model","text":"# generate timeline\ndϵ = timeline(t_start = 1e-2, t_end = 1e1)\n# calculates strain data by applying a function of time\ndϵ = strainfunction(dϵ, hstep())\n\n# Fix model parameters\npowermodel = RheoModel(PowerLawEmpirical, A = 1, α = 0.8)\n\n# Evaluate relaxation response\ndpower = modelpredict(dϵ, powermodel)\n\nfig, ax = subplots(1, 1, figsize = (3, 3))\nax.loglog(dpower.t, dpower.σ)\nax.set_xlabel(\"Time\")\nax.set_ylabel(\"Stress\")\nax.set_ylim(bottom = 0.1, top = 20)\nax.grid(\"on\")\nfig #hide","category":"page"},{"location":"model_create/","page":"Create Your Model","title":"Create Your Model","text":"In a similar way, it is possible to define a model with only creep modulus. In this case, only strain can be fitted/predicted.","category":"page"},{"location":"model_create/","page":"Create Your Model","title":"Create Your Model","text":"","category":"page"},{"location":"model_create/","page":"Create Your Model","title":"Create Your Model","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/model_maxwell.jl\"","category":"page"},{"location":"model_maxwell/#Fractional-Maxwell","page":"Maxwell","title":"Fractional Maxwell","text":"","category":"section"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"(Image: ) (Image: )","category":"page"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"using RHEOS\n# include a helper function for plotting\ninclude(\"assets/plothelper.jl\");\nnothing #hide","category":"page"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"Fract_Maxwell","category":"page"},{"location":"model_maxwell/#Constitutive-Equation","page":"Maxwell","title":"Constitutive Equation","text":"","category":"section"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"sigma(t) + fracc_alphac_beta fracd^alpha-beta sigma(t)dt^alpha-beta= c_alpha fracd^alpha epsilon(t)dt^alpha","category":"page"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"textfor  0 leq beta leq alpha leq 1","category":"page"},{"location":"model_maxwell/#Relaxation-Modulus","page":"Maxwell","title":"Relaxation Modulus","text":"","category":"section"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"G(t) = c_beta t^-beta E_alpha-beta1-betaleft(-fracc_betac_alpha t^alpha-betaright)","category":"page"},{"location":"model_maxwell/#Creep-Modulus","page":"Maxwell","title":"Creep Modulus","text":"","category":"section"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"J(t) = frac1c_alpha Gamma(1+alpha)t^alpha+frac1c_beta Gamma(1+beta)t^beta","category":"page"},{"location":"model_maxwell/#Storage-Modulus","page":"Maxwell","title":"Storage Modulus","text":"","category":"section"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"G^prime(omega) = fracleft(c_beta omega^betaright)^2 cdot c_alpha omega^alpha cos(alpha fracpi2) + left(c_alpha omega^alpharight)^2 cdot c_beta omega^beta cos(beta fracpi2)left(c_alpha omega^alpharight)^2+left(c_beta omega^betaright)^2+2c_alpha omega^alpha cdot c_beta omega^beta cos((alpha-beta)fracpi2)","category":"page"},{"location":"model_maxwell/#Loss-Modulus","page":"Maxwell","title":"Loss Modulus","text":"","category":"section"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"G^primeprime(omega) = fracleft(c_beta omega^betaright)^2 cdot c_alpha omega^alpha sin(alpha fracpi2) + left(c_alpha omega^alpharight)^2 cdot c_beta omega^beta sin(beta fracpi2)left(c_alpha omega^alpharight)^2+left(c_beta omega^betaright)^2+2c_alpha omega^alpha cdot c_beta omega^beta cos((alpha-beta)fracpi2)","category":"page"},{"location":"model_maxwell/#Fractional-(Spring)-Maxwell","page":"Maxwell","title":"Fractional (Spring) Maxwell","text":"","category":"section"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"FractS_Maxwell","category":"page"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying α\nfor alpha in [0.1, 0.3, 0.5, 0.7, 0.9]\n\n    push!(models, RheoModel(FractS_Maxwell, (cₐ = 1.0, a = alpha, k = 1.0)))\n\nend\n\nplotmodel(models)","category":"page"},{"location":"model_maxwell/#Fraction-(Dashpot)-Maxwell","page":"Maxwell","title":"Fraction (Dashpot) Maxwell","text":"","category":"section"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"FractD_Maxwell","category":"page"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying β\nfor beta in [0.1, 0.3, 0.5, 0.7, 0.9]\n\n    push!(models, RheoModel(FractD_Maxwell, (η = 10, cᵦ= 1.0, β = beta)))\n\nend\n\nplotmodel(models, ymaxG = 2.0)","category":"page"},{"location":"model_maxwell/#Maxwell","page":"Maxwell","title":"Maxwell","text":"","category":"section"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"Maxwell","category":"page"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying k\nfor k in [5.0, 10.0, 20.0]\n\n    push!(models, RheoModel(Maxwell, (η = 10, k = k)))\n\nend\n\nplotmodel(models)","category":"page"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"","category":"page"},{"location":"model_maxwell/","page":"Maxwell","title":"Maxwell","text":"This page was generated using Literate.jl.","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/numerical.jl\"","category":"page"},{"location":"numerical/#Numerical-Aspects","page":"Numerical Aspects","title":"Numerical Aspects","text":"","category":"section"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"(Image: ) (Image: )","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"note: Note\nThis section is still under development.","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"using RHEOS","category":"page"},{"location":"numerical/#Constant-vs.-Variable-Sample-Rate","page":"Numerical Aspects","title":"Constant vs. Variable Sample Rate","text":"","category":"section"},{"location":"numerical/#Weight-indices-rather-than-using-a-variable-sample-rate","page":"Numerical Aspects","title":"Weight indices rather than using a variable sample rate","text":"","category":"section"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"There may be situations when it is appropriate to focus the model fitting process on particular regions of the data. This may occur, for example, when the small time scale loading region is of particular interest. To achieve this, we could send data to fit that is sampled variably, with a greater sample density near the region of interest. However, the variable sampling rate means that the method RHEOS uses to compute the model predictions is slower and less accurate.","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"A more optimal solution is to send constant sample rate data to the fitting function, but ask RHEOS to modify the final cost function to focus on specific points. In this way, RHEOS will be able to benefit from the much faster and more accurate constant sample rate model simulation methods.","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"In concrete terms, consider the following array of time samples:","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"t = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5];\nnothing #hide","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"We can send another array to the fitting process, weightings, that tells RHEOS to weight the first three time samples as doubly important, and the subsequent samples as half as important. The array we send would look like this:","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"weightings = [1, 1, 2, 2, 3, 3, 4, 6];\nnothing #hide","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"In words, the elements in the time region we are particularly concerned about (0 ≤ t ≤ 0.2) are considered twice in the final fitting cost function, whereas we only consider every other element for times after 0.2 seconds.","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"For practical situations, when working with data embedded in RheoTimeData structs, RHEOS has a convenience function indexweight which makes it easy to generate a weightings array that can then be passed to either modelfit or modelstepfit. The full description of indexweight can be found in the API section. Below, we include a typical example of its use, based on the same data used in Fitting and Predicting - Time Data.","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"# As in original example, load in the data\ndata = importcsv(\"assets/data_time.csv\", t_col = 1, ϵ_col = 2, σ_col = 3)\nrheotimedatatype(data)","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"Now instead of going straight to fitting, we will construct a weightings array using indexweight.","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"# construct weighted array\nweightings = indexweight(data; elperiods = [2, 3, -2], time_boundaries = [0.0, 0.5, 1.0, data.t[end]])\n\n# fit model with weighted array\nmodelfit(data, Maxwell, strain_imposed, weights = weightings)","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"We note that the results are slightly different from the original example in Fitting and Predicting - Time Data due to the element weighting provided to the fitting function.","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"","category":"page"},{"location":"numerical/","page":"Numerical Aspects","title":"Numerical Aspects","text":"This page was generated using Literate.jl.","category":"page"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/model_zener.jl\"","category":"page"},{"location":"model_zener/#Fractional-Zener","page":"Zener","title":"Fractional Zener","text":"","category":"section"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"(Image: ) (Image: )","category":"page"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"using RHEOS\n# include a helper function for plotting\ninclude(\"assets/plothelper.jl\");\nnothing #hide","category":"page"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"Fract_Zener","category":"page"},{"location":"model_zener/#Constitutive-Equation","page":"Zener","title":"Constitutive Equation","text":"","category":"section"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"sigma(t) + fracc_alphac_beta fracd^alpha-beta sigma(t)dt^alpha-beta= c_alpha fracd^alpha epsilon(t)dt^alpha + c_gamma fracd^gamma epsilon(t)dt^gamma+ fracc_alpha c_gammac_betafracd^alpha+gamma-beta epsilon(t)dt^alpha+gamma-beta","category":"page"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"textfor  0 leq beta leq alpha leq 1","category":"page"},{"location":"model_zener/#Relaxation-Modulus","page":"Zener","title":"Relaxation Modulus","text":"","category":"section"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"G(t) = c_beta t^-beta E_alpha-beta1-betaleft(-fracc_betac_alpha t^alpha-betaright) + fracc_gamma Gamma(1-gamma) t^-gamma","category":"page"},{"location":"model_zener/#Creep-Modulus","page":"Zener","title":"Creep Modulus","text":"","category":"section"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"tildeJ(s)= frac1sfracc_alpha s^alpha+c_beta s^betac_alpha s^alpha c_beta s^beta + c_gamma s^gamma (c_alpha s^alpha+c_beta s^beta)","category":"page"},{"location":"model_zener/#Storage-Modulus","page":"Zener","title":"Storage Modulus","text":"","category":"section"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"G^prime(omega) = fracleft(c_beta omega^betaright)^2 cdot c_alpha omega^alpha cos(alpha fracpi2) + left(c_alpha omega^alpharight)^2 cdot c_beta omega^beta cos(beta fracpi2)left(c_alpha omega^alpharight)^2+left(c_beta omega^betaright)^2+2c_alpha omega^alpha cdot c_beta omega^beta cos((alpha-beta)fracpi2) + c_gamma omega^gamma cosleft(gamma fracpi2right)","category":"page"},{"location":"model_zener/#Loss-Modulus","page":"Zener","title":"Loss Modulus","text":"","category":"section"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"G^primeprime(omega) = fracleft(c_beta omega^betaright)^2 cdot c_alpha omega^alpha sin(alpha fracpi2) + left(c_alpha omega^alpharight)^2 cdot c_beta omega^beta sin(beta fracpi2)left(c_alpha omega^alpharight)^2+left(c_beta omega^betaright)^2+2c_alpha omega^alpha cdot c_beta omega^beta cos((alpha-beta)fracpi2)+ c_gamma omega^gamma sinleft(gamma fracpi2right)","category":"page"},{"location":"model_zener/#Fractional-SLS-(Zener)","page":"Zener","title":"Fractional SLS (Zener)","text":"","category":"section"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"FractSLS_Zener","category":"page"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying α\nfor alpha in [0.1, 0.25, 0.5, 0.74, 0.9]\n\n    push!(models, RheoModel(FractSLS_Zener, (cₐ = 1, a = alpha, kᵦ = 1, kᵧ = 1)))\n\nend\n\nplotmodel(models)","category":"page"},{"location":"model_zener/#Fractional-Jeffreys-(Zener)","page":"Zener","title":"Fractional Jeffreys (Zener)","text":"","category":"section"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"FractJeffreys_Zener","category":"page"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying β\nfor beta in [0.1, 0.25, 0.5, 0.74, 0.9]\n\n    push!(models, RheoModel(FractJeffreys_Zener, (ηₐ = 1, cᵦ = 1, β = beta, ηᵧ = 1)))\n\nend\n\nplotmodel(models, ymaxG = 2.0)","category":"page"},{"location":"model_zener/#Standard-Linear-Solid-(Zener)","page":"Zener","title":"Standard Linear Solid (Zener)","text":"","category":"section"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"SLS_Zener","category":"page"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying kᵦ\nfor k in [1.0, 3.0, 5.0]\n\n    push!(models, RheoModel(SLS_Zener, (η = 1, kᵦ = k, kᵧ = 1)))\n\nend\n\nplotmodel(models)","category":"page"},{"location":"model_zener/#Jeffreys-(Zener)","page":"Zener","title":"Jeffreys (Zener)","text":"","category":"section"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"Jeffreys_Zener","category":"page"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying ηₐ\nfor eta in [1.0, 5.0, 8.0]\n\n    push!(models, RheoModel(Jeffreys_Zener, (ηₐ = eta, k = 3, ηᵧ = 1)))\n\nend\n\nplotmodel(models)","category":"page"},{"location":"model_zener/#Fractional-Solid","page":"Zener","title":"Fractional Solid","text":"","category":"section"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"FractSolid","category":"page"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"models = Vector{RheoModel}()\n\n# plot moduli for varying β\nfor beta in [0.1, 0.25, 0.5, 0.74, 0.9]\n\n    push!(models, RheoModel(FractSolid, (η = 1, cᵦ = 1, β = beta, k = 0.5)))\n\nend\n\nplotmodel(models, ymaxG = 2)","category":"page"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"","category":"page"},{"location":"model_zener/","page":"Zener","title":"Zener","text":"This page was generated using Literate.jl.","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/fileio.jl\"","category":"page"},{"location":"fileio/#File-I/O","page":"File I/O","title":"File I/O","text":"","category":"section"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"(Image: ) (Image: )","category":"page"},{"location":"fileio/#Import-Data","page":"File I/O","title":"Import Data","text":"","category":"section"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"using RHEOS","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"RHEOS has a convenience function for importing data from CSV files: importcsv. The default column delimiter is , but an alternative can be specified as a keyword argument. The row delimiter is a newline character (\\n). For standard time-domain viscoelastic testing data RHEOS expects either stress, strain and time data, just stress and time, or just strain and time. Arguments must be identified by providing the number of the column in which they are contained. The function returns a RheoTimeData object.","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"# Import file\ndata_1 = importcsv(\"assets/data_time.csv\", t_col = 1, ϵ_col = 2, σ_col = 3)\n# Check data type\nrheotimedatatype(data_1)\n\n# Import incomplete data\ndata_2 = importcsv(\"assets/data_time.csv\", t_col = 1, ϵ_col = 2)\n# Check data type\nrheotimedatatype(data_2)","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"The function importcsv can also be used to import frequency, storage modulus, and loss modulus data (as a complete set). In this case, the function returns a RheoFreqData object.","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"# Import file\ndata_f = importcsv(\"assets/data_freq.csv\", ω_col = 1, Gp_col = 2, Gpp_col = 3)\n# Check data type\nrheofreqdatatype(data_f)","category":"page"},{"location":"fileio/#Export-Data","page":"File I/O","title":"Export Data","text":"","category":"section"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"If you want to analyse or plot your data in software other than Julia you will likely want to export it to a CSV file. To export RheoTimeData and RheoFreqData objects to CSV files we can use the exportcsv function. For the two complete data-sets we imported above, we can export them into new files in the following way. As with importcsv, the order of the columns can be specified by the user.","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"# Export file\nexportcsv(data_1, \"assets/export_timedata.csv\")\nexportcsv(data_f, \"assets/export_frequdata.csv\")","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"","category":"page"},{"location":"fileio/","page":"File I/O","title":"File I/O","text":"This page was generated using Literate.jl.","category":"page"},{"location":"API/#API","page":"API","title":"API","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/edit/master/docs/src/API.md\"","category":"page"},{"location":"API/#Main-RHEOS-data-structures","page":"API","title":"Main RHEOS data structures","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"RheoTimeData\nRheoFreqData\ngettime\ngetstress\ngetstrain\ngetfreq\ngetstorage\ngetloss","category":"page"},{"location":"API/#RHEOS.RheoTimeData","page":"API","title":"RHEOS.RheoTimeData","text":"RheoTimeData(;σ::Vector{T1}, ϵ::Vector{T2}, t::Vector{T3}) where {T1<:Real, T2<:Real, T3<:Real}\n\nRheoTimeData struct contains stress, strain and time data.\n\nIf preferred, an instance can be generated manually by just providing the three data vectors in the right order, sampling type will be checked automatically.\n\nFields\n\nσ: stress\nϵ: strain\nt: time\nlog: a log of struct's events, e.g. preprocessing\n\n\n\n\n\n","category":"type"},{"location":"API/#RHEOS.RheoFreqData","page":"API","title":"RHEOS.RheoFreqData","text":"RheoFreqData(Gp::Vector{T1}, Gpp::Vector{T2}, ω::Vector{T3}, log::OrderedDict{Any,Any}) where {T1<:Real, T2<:Real, T3<:Real}\n\nRheoFreqData contains storage modulus, loss modulus and frequency data.\n\nIf preferred, an instance can be generated manually by just providing the three data vectors in the right order.\n\nFields\n\nGp: storage modulus\nGpp: loss modulus\nω: frequency\nlog: a log of struct's events, e.g. preprocessing\n\n\n\n\n\n","category":"type"},{"location":"API/#RHEOS.gettime","page":"API","title":"RHEOS.gettime","text":"gettime(d::RheoTimeData)\n\nreturns the time vector.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.getstress","page":"API","title":"RHEOS.getstress","text":"getstress(d::RheoTimeData)\n\nreturns the stress vector if d contains stress data.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.getstrain","page":"API","title":"RHEOS.getstrain","text":"getstrain(d::RheoTimeData)\n\nreturns the strain vector if d contains strain data.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.getfreq","page":"API","title":"RHEOS.getfreq","text":"getomega(d::RheoFreqData)\n\nreturns the frequency ω vector.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.getstorage","page":"API","title":"RHEOS.getstorage","text":"getstorage(d::RheoFreqData)\n\nreturns the storage modulus vector.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.getloss","page":"API","title":"RHEOS.getloss","text":"getloss(d::RheoFreqData)\n\nreturns the loss modulus vector.\n\n\n\n\n\n","category":"function"},{"location":"API/#Moduli/compliance-functions","page":"API","title":"Moduli/compliance functions","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"RheoModelClass\nRheoModel\ngetparams\nfreezeparams\nrelaxmod\ncreepcomp\nstoragemod\nlossmod\ndynamicmod","category":"page"},{"location":"API/#RHEOS.RheoModelClass","page":"API","title":"RHEOS.RheoModelClass","text":"RheoModelClass(;name::String, p::Tuple, G,J,Gp,Gpp, constraint, info, G_ramp)\n\nRheoModelClass is a complex data structure that contains all the relevant data to  allow RHEOS to fit models and make predictions once parameters are set. RHEOS possesses already a large number of such data structures to represent common rheological models, such as Maxwell or KelvinVoigt.\n\nUsers are not expected to directly manipulate the content of a RheoModelClass object, but will  pass it to relevant functions for fitting and numerically evaluating visco-elastic moduli.\n\nThe model name and its parameters can however be printed and display on the REPL.\n\nExample\n\njulia> Maxwell\n\nModel name: maxwell\n\nFree parameters: η and k\n\n                ___\n            _____| |________╱╲  ╱╲  ╱╲  ___\n                _|_|          ╲╱  ╲╱  ╲╱\n                  η                  k\n               \n\n\n\n\n\n","category":"type"},{"location":"API/#RHEOS.RheoModel","page":"API","title":"RHEOS.RheoModel","text":"RheoModel(m::RheoModelClass, nt0::NamedTuple)\n\nRheoModel represents a rheological model with set parameters. They are obtained by fitting a model to data using modelfit,  or by specialising the relevant RheoModelClass by prescribing its parameters. Parameters can be provided as a named tuple or keyword arguments.\n\nRheoModel objects can then be used to simulate the response to an arbitrary input using modelpredict, and access the values of the moduli functions.\n\nExample\n\njulia> model = RheoModel(Maxwell, (k=1, η=2.))\n[...]\n\njulia> model = RheoModel(Maxwell, k=1, η=2.)\n[...]\n\n\n\n\n\n","category":"type"},{"location":"API/#RHEOS.getparams","page":"API","title":"RHEOS.getparams","text":"getparams(m::RheoModel; unicode=true)\n\ngetparams return the list of model parameters with their values as a NamedTuple. If unicode is set to false, the unicode symbols are converted their text equivalent.\n\nExample\n\njulia> model = RheoModel(Maxwell, k=1, η=2.)\n[...]\n\njulia> getparams(m)\n(k = 1.0, η = 2.0)\n\njulia> getparams(m,unicode=false)\n(k = 1.0, eta = 2.0)\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.freezeparams","page":"API","title":"RHEOS.freezeparams","text":"freezeparams(m::RheoModelClass, nt0::NamedTuple)\n\nReturn a new RheoModelClass with some of the parameters frozen to specific values\n\nArguments\n\nm: original RheoModelClass\nnt0: named tuple with values for each parameter to freeze\n\nExample\n\njulia> SLS2_mod = freezeparams( SLS2, (G₀=2,η₂=3.5))\n[...]\n\njulia> SLS2.G(1,[2,1,2,3,3.5])\n3.8796492\n\njulia> SLS2_mod.G(1,[1,2,3])\n3.8796492\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.relaxmod","page":"API","title":"RHEOS.relaxmod","text":"relaxmod(m[, t, params])\n\nprovide access to the relaxation modulus (G) of a given model m. It can be used with a broad range of inputs.\n\nWhen a time value is provided (or an array of time values), the function returns the corresponding value(s) of the relaxation modulus.\nrelaxmod(m::RheoModel, time (single value or array))\nrelaxmod(m::RheoModelClass, time (single value or array), parameters (array, named tupple or keyword parameters))\n\nExamples:\n\nrelaxmod(Maxwell, 1, k=1., η=1)\n\nrelaxmod(Maxwell, [1,2,3], [1,1])\n\nWhen no time value is provided, relaxmod returns the relaxation function itself.\nrelaxmod(m::RheoModel)\nrelaxmod(m::RheoModelClass, parameters (array, named tupple or keyword parameters))\n\nExamples:\n\nm = RheoModel(Maxwell, k=1., η=1)\nG = relaxmod(m)\nG([0,1,2])\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.creepcomp","page":"API","title":"RHEOS.creepcomp","text":"creepcomp(m[, t, params])\n\nprovide access to the creep compliance (J) of a given model m. It can be used with a broad range of inputs.\n\nWhen a time value is provided (or an array of time values), the function returns the corresponding value(s) of the creep compliance.\ncreepcomp(m::RheoModel, time (single value or array))\ncreepcomp(m::RheoModelClass, time (single value or array), parameters (array, named tupple or keyword parameters))\n\nExamples:\n\ncreepcomp(Maxwell, 1, k=1., η=1)\n\ncreepcomp(Maxwell, [1,2,3], [1,1])\n\nWhen no time value is provided, creepcomp returns the creep compliance function itself.\ncreepcomp(m::RheoModel)\ncreepcomp(m::RheoModelClass, parameters (array, named tupple or keyword parameters))\n\nExamples:\n\nm = RheoModel(Maxwell, k=1., η=1)\nJ = creepcomp(m)\nJ([0,1,2])\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.storagemod","page":"API","title":"RHEOS.storagemod","text":"storagemod(m[, ω, params])\n\nprovide access to the storage modulus (G') of a given model m.\n\nWhen a frequency value is provided (or an array of frequency values), the function returns the corresponding value(s) of the storage modulus.\nstoragemod(m::RheoModel, frequency (single value or array))\nstoragemod(m::RheoModelClass, frequency (single value or array), parameters (array, named tupple or keyword parameters))\n\nExamples:\n\nstoragemod(Maxwell, 1, k=1., η=1)\n\nstoragemod(Maxwell, [1,2,3], [1,1])\n\nWhen no time value is provided, storagemod returns the storage modulus function itself.\nstoragemod(m::RheoModel)\nstoragemod(m::RheoModelClass, parameters (array, named tupple or keyword parameters))\n\nExamples:\n\nm = RheoModel(Maxwell, k=1., η=1)\nGp = storagemod(m)\nGp([0,1,2])\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.lossmod","page":"API","title":"RHEOS.lossmod","text":"lossmod(m[, ω, params])\n\nprovide access to the loss modulus (G'') of a given model m.\n\nWhen a frequency value is provided (or an array of frequency values), the function returns the corresponding value(s) of the loss modulus.\nlossmod(m::RheoModel, frequency (single value or array))\nlossmod(m::RheoModelClass, frequency (single value or array), parameters (array, named tupple or keyword parameters))\n\nExamples:\n\nlossmod(Maxwell, 1, k=1., η=1)\n\nlossmod(Maxwell, [1,2,3], [1,1])\n\nWhen no time value is provided, lossmod returns the loss modulus function itself.\nlossmod(m::RheoModel)\nlossmod(m::RheoModelClass, parameters (array, named tupple or keyword parameters))\n\nExamples:\n\nm = RheoModel(Maxwell, k=1., η=1)\nGpp = lossmod(m)\nGpp([0,1,2])\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.dynamicmod","page":"API","title":"RHEOS.dynamicmod","text":"dynamicmod(m[, ω, params])\n\nprovide access to the complex dynamic modulus (G' + i G'') of a given model m.\n\nWhen a frequency value is provided (or an array of frequency values), the function returns the corresponding value(s) of the complex dynamic modulus.\ndynamicmod(m::RheoModel, frequency (single value or array))\ndynamicmod(m::RheoModelClass, frequency (single value or array), parameters (array, named tupple or keyword parameters))\n\nExamples:\n\ndynamicmod(Maxwell, 1, k=1., η=1)\n\ndynamicmod(Maxwell, [1,2,3], [1,1])\n\nWhen no time value is provided, lossmod returns the complex dynamic modulus function itself.\ndynamicmod(m::RheoModel)\ndynamicmod(m::RheoModelClass, parameters (array, named tupple or keyword parameters))\n\nExamples:\n\nm = RheoModel(Maxwell, k=1., η=1)\nGpp = dynamicmod(m)\nGpp([0,1,2])\n\nNote: use abs() and angle() to get the magnitude and phase of the complex modulus.\n\n\n\n\n\n","category":"function"},{"location":"API/#Sampling-and-Filtering-Functions","page":"API","title":"Sampling and Filtering Functions","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"resample\nindexweight\ncutting\nsmooth\nonlytime\nonlystrain\nonlystress\nonlyfreq\nextract","category":"page"},{"location":"API/#RHEOS.resample","page":"API","title":"RHEOS.resample","text":"resample(d::RheoTimeData [, t, dt, scale )\n\nResample the data using 1D spline extrapolation (using the Dierckx.jl package).\n\nArguments\n\nd: data as a RheoTimeData struct containing time with stress and/or strain. Without additional parameters, the data is resampled to provide a uniform sampling at constant number of timepoints.\nt: an array or range that determines the timepoints where the data will be provided.\ndt: if the array t is not provided, the parameter dt will set the timestep for a uniform resampling of the data.\nscale: instead of specifying particular time points or timestep, an overall multiplicator on the sampling rate can be provided. This could down-sample (scale<1) or upsample (scale>1). If timesteps are non uniform, it would interpolate values accordingly.\n\nExamples\n\nAssuming d is a RheoTimeData data set:\n\nresample(d) keeps the number of sampling points the same but interpolates to set a uniform time step.\nresample(d, t=-1:0.1:10) resamples by interpolation to generate a new dataset with time points given by the range t.\nresample(d, dt=0.1) resamples by interpolation to generate a new dataset with uniform time step dt.\nresample(d, scale=2) resamples by multiplying the sampling rate by 2.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.indexweight","page":"API","title":"RHEOS.indexweight","text":"indexweight(self::RheoTimeData; elperiods::Vector{K}, time_boundaries::Union{Nothing, Vector{T}} = nothing, includelast=true) where {K<:Integer,T<:Real}\n\nThis function returns array indices (i.e. an array of integers) which can be sent to the modelfit, modelstepfit or modeldiffeqfit functions to provide a weighted fitting whilst maintaining constant sample-rate.\n\nNote that time_boundaries must have one more entry than elperiods so that all sections of weighting are fully defined by beginning and end points.\n\nindexweight can underweight indices or overweight them. If elperiods in a given boundary is negative, every abs(n) index will be used, where n is the elperiod corresponding to a given boundary. If n is positive, then indicies will be duplicated n times such that they are given a higher weighting during the fitting procedure. If number of elements per period (elperiods) is 1 or -1 it returns the original indicies for that boundary, whilst 0 is not accepted as a valid argument for elperiods.\n\nThe last element may or may not be included. By default the last element is forced to be included but this can be negated by providing the keyword argument includelast=false.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.cutting","page":"API","title":"RHEOS.cutting","text":"cutting(self::RheoTimeData, time_on::Real, time_off::Real)\n\nRemove the data outside a specified time interval.\n\nBy specifing a time interval (time_on, time_off), a new RheoTimeData is returned without the data lying outside time interval.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.smooth","page":"API","title":"RHEOS.smooth","text":"smooth(self::RheoTimeData, τ::Real; pad::String=\"reflect\")\n\nSmooth data using a Gaussian Kernel to time scale τ (approximately half power).\n\nSmooths both σ and ϵ. Sampling frequency must be constant as it is based on FFT convolution. Essentially a low pass filter with frequencies of 1/τ being cut to approximately half power. For other pad types available see ImageFiltering documentation. As of doc writing, pad options are: \"replicate\" (repeat edge values to infinity), \"circular\" (image edges \"wrap around\"), \"symmetric\" (the image reflects relative to a position between pixels), \"reflect\" (the image reflects relative to the edge itself).\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.onlytime","page":"API","title":"RHEOS.onlytime","text":"onlytime(d::RheoTimeData)\n\nReturn a RheoTimeData object with only the timeline of the parameter d.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.onlystrain","page":"API","title":"RHEOS.onlystrain","text":"onlystrain(d::RheoTimeData)\n\nReturn a RheoTimeData object with only the time and strain data of the parameter d.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.onlystress","page":"API","title":"RHEOS.onlystress","text":"onlystress(d::RheoTimeData)\n\nReturn a RheoTimeData object with only the time and stress data of the parameter d.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.onlyfreq","page":"API","title":"RHEOS.onlyfreq","text":"onlyfreq(d::RheoFreqData)\n\nReturn a RheoFreqData object with only the frequency data of the parameter d.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.extract","page":"API","title":"RHEOS.extract","text":"extract(self::Union{RheoTimeData,RheoFreqData}, type::Union{TimeDataType,FreqDataType,Integer})\n\nExtract specific fields form RheoTimeData or RheoFreqData.\n\nDeprecated - prefer to use the functions onlytime, onlystrain, onlystress, and onlyfreq.\n\nExtract can copy one or more fields from a given RheoXData variable into a new RheoXData one. The fields that are copied are identified by the specified type of data. If self is a RheoTimeData, the type that can be extracted is time_only (or 0), stress_only (or 1), strain_only (or 2). Note that strain_and_stress (or 3) is not allowed. If self is a RheoFreqData, the type that can be extracted is freq_only (or 0).\n\n\n\n\n\n","category":"function"},{"location":"API/#Fitting-and-Predicting-Functions","page":"API","title":"Fitting and Predicting Functions","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"modelfit\nmodelpredict\nmodelstepfit\nmodelsteppredict\ndynamicmodelfit\ndynamicmodelpredict","category":"page"},{"location":"API/#RHEOS.modelfit","page":"API","title":"RHEOS.modelfit","text":"modelfit(data::RheoTimeData, model::RheoModelClass, modloading::Symbol; p0::Union{NamedTuple,Nothing} = nothing, lo::Union{NamedTuple,Nothing} = nothing, hi::Union{NamedTuple,Nothing} = nothing, verbose::Bool = false, rel_tol = 1e-4, diff_method=\"BD\", weights::Union{Vector{Integer},Nothing}=nothing)\n\nFit RheologyData struct to model and return a fitted model as a RheologyModel object. For the fitting process RHEOS relies on the optimistion package NLopt.jl (https://nlopt.readthedocs.io/en/latest/). RHEOS makes use of a local derivative free algorithm, specifically the Tom Rowan's \"Subplex\"\n\nArguments\n\ndata: RheoTimeData struct containing all data\nmodel: RheoModelClass containing moduli functions and named tuple parameters\nmodloading: strain_imposed or 1, stress_imposed or 2\np0: Initial parameters to use in fit (uses 0.5 for all parameters if not defined)\nlo: Lower bounds for parameters\nhi: Upper bounds for parameters\nverbose: If true, prints parameters on each optimisation iteration\nrel_tol: Relative tolerance of optimization, see NLOpt docs for more details\ndiff_method: Set finite difference formula to use for derivative, currently \"BD\" or \"CD\"\nweights: Vector of indices weighted according to importance, can be generated by indexweight function\noptmethod: optimisation algorithm used by NLOpt. \n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.modelpredict","page":"API","title":"RHEOS.modelpredict","text":"modelpredict(data::RheoTimeData, model::RheoModel; diff_method=\"BD\")\n\nGiven an incomplete data set (only either stress or strain missing) and model with values substituted into parameters (RheoModel), return a new dataset based on the model. If data is type of stress_only, then creep modulus (:J) is used; if data type is strain_only relaxation modulus (:G). A complete RheoTimeData of type strain_and_stress is returned. diff_method sets finite difference for calculating the derivative used in the hereditary integral and can be either backwards difference (\"BD\") or central difference (\"CD\").\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.modelstepfit","page":"API","title":"RHEOS.modelstepfit","text":"modelstepfit(data::RheoTimeData, model::RheoModelClass, modloading::Union{LoadingType,Integer}; step=nothing, p0::Union{NamedTuple,Nothing} = nothing, lo::Union{NamedTuple,Nothing} = nothing, hi::Union{NamedTuple,Nothing} = nothing, verbose::Bool = false, rel_tol = 1e-4, weights::Union{Vector{Integer},Nothing} = nothing)\n\nSame as modelfit except assumes a step loading. If this assumption is appropriate for the data then fitting can be sped up greatly by use of this function. If modloading is strain_imposed, relaxation modulus is used, then the element in the middle of the strain is assumed to be the amplitude of the step. If modloading is stress_imposed, the creep modulus is used, then the middle element of the stress is assumed to be the amplitude of the step. Alternatively, it is possible to define the value of the step by defining the optional step parameter.\n\nArguments\n\ndata: RheoTimeData struct containing all data\nmodel: RheoModelClass containing moduli and parameters tuples\nmodloading: strain_imposed for relaxation modulus, stress_imposed for creep modulus\nstep: Optional amplitude for step\np0: Named tuple of initial parameters to use in fit (uses 0.5 for all parameters if none given)\nlo: Named tuple of lower bounds for parameters\nhi: Named tuple of upper bounds for parameters\nverbose: If true, prints parameters on each optimisation iteration\nrel_tol: Relative tolerance of optimization, see NLOpt docs for more details\nweights: Vector of indices weighted according to importance, can be generated by indexweight function\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.modelsteppredict","page":"API","title":"RHEOS.modelsteppredict","text":"modelsteppredict(data::RheoTimeData, model::RheoModel; step_on::Real = 0.0)\n\nSame as modelpredict but assumes a step loading with step starting at step_on or closest actual value to that specified. If the loading data is variable, the magnitude in the middle of the array is used.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.dynamicmodelfit","page":"API","title":"RHEOS.dynamicmodelfit","text":"dynamicmodelfit(data::RheoFreqData, model::RheoModelClass; p0::Union{NamedTuple,Nothing} = nothing, lo::Union{NamedTuple,Nothing} = nothing, hi::Union{NamedTuple,Nothing} = nothing, verbose::Bool = false, rel_tol = 1e-4) where T<:Real\n\nFits model to the frequency/loss+storage moduli data.\n\nAll arguments are as described below. As this fitting procedure is fitting two functions simultaneously (the storage and loss moduli), if left untransformed the fit would tend to favour the modulus which is larger in magnitude and not fit the other modulus well. To avoid this, RHEOS offers a number of data transforms which can be used by changing weights argument.\n\nArguments\n\ndata: RheoFreqData struct containing all data\nmodel: RheoModelClass containing moduli and symbols of parameters\np0: Initial parameters to use in fit (uses 0.5 for all parameters if none given)\nlo: Lower bounds for parameters\nhi: Upper bounds for parameters\nverbose: If true, prints parameters on each optimisation iteration\nrel_tol: Relative tolerance of optimization, see NLOpt docs for more details\nweights: Weighting mode for storage and loss modulus (\"none\", \"mean\", \"log\", \"local\" or manually specified)\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.dynamicmodelpredict","page":"API","title":"RHEOS.dynamicmodelpredict","text":"dynamicmodelpredict(data::RheoFreqData, model::RheoModel)\n\nGiven dynamic rheology data with only frequency and model where parameters have been substituted. Returns another RheoFreqData instance with the predicted Gp and Gpp based on the frequencies and model given as arguments.\n\n\n\n\n\n","category":"function"},{"location":"API/#Data-Generation-Functions","page":"API","title":"Data Generation Functions","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"timeline\nstrainfunction\nstressfunction\nhstep\nramp\nstairs\nsquare\nsawtooth\ntriangle\nfrequencyspec","category":"page"},{"location":"API/#RHEOS.timeline","page":"API","title":"RHEOS.timeline","text":"timeline(r)\n\nGenerate RheoTimeData struct with only the time data based on the range provided.\n\nExample:\n\ntimeline(0:0.1:10) returns a RheoTimeData with only time data, with the following series: [0.  0.1   0.2  ...  9.9  10].\n\n\n\n\n\ntimeline(;t_start::Real=0., t_end::Real, step::Real=(t_end - t_start)/250.)\n\nGenerate RheoTimeData struct with only the time data based on the keywords provided.\n\nArguments\n\nt_start: Starting time, typically 0\nt_end: End time\nstep: Time between sample. Default set in order to provide ≈ 250 time points.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.strainfunction","page":"API","title":"RHEOS.strainfunction","text":"strainfunction(data::RheoTimeData, f::T) where T<:Function\n\nAccepts a RheoTimeData and outputs a new RheoTimeData with a strain imposed. The strain signal is determined by the function provided, which should take time as its only argument. The original data's time signal is used.\n\nNormally used with a RheoTimeData generated using the timeline function.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.stressfunction","page":"API","title":"RHEOS.stressfunction","text":"stressfunction(data::RheoTimeData, f::T) where T<:Function\n\nAccepts a RheoTimeData and outputs a new RheoTimeData with a stress imposed. The stress signal is determined by the function provided, which should take time as its only argument. The original data's time signal is used.\n\nNormally used with a RheoTimeData generated using the timeline function.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.hstep","page":"API","title":"RHEOS.hstep","text":"hstep(t; offset=0., amp=1.)\n\nStep generation function for use with stressfunction or strainfunction. offset keyword arguent determines start of step. amp argument determines amplitude (height) of step.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.ramp","page":"API","title":"RHEOS.ramp","text":"ramp(t; offset=0., gradient=1.)\n\nRamp signal generation function for use with stressfunction or strainfunction. offset keyword argument determines start of ramp. gradient argument determines the linear gradient of the ramp.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.stairs","page":"API","title":"RHEOS.stairs","text":"stairs(t; offset=0., amp=1., width=1.)\n\nStairs signal generation function for use with stressfunction or strainfunction. Equivalent to additional steps being added every width seconds. offset keyword argument determines start of stairs signal. amp argument determines the height of each additional step.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.square","page":"API","title":"RHEOS.square","text":"square(t; offset=0., amp=1., period=1., width=0.5*period)\n\nSquare signal generation function for use with stressfunction or strainfunction. offset keyword argument determines start of square signal. amp argument determines the height of each square pulse. period determines the period of one off/on section of the square wave signal. width determines the width of each square pulse.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.sawtooth","page":"API","title":"RHEOS.sawtooth","text":"sawtooth(t; offset=0., amp=1., period=1.)\n\nSawtooth signal generation function for use with stressfunction or strainfunction. offset keyword argument determines start of sawtooth signal. amp argument determines the height of each sawtooth pulse. period determines the period of the sawtooth wave signal.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.triangle","page":"API","title":"RHEOS.triangle","text":"triangle(t; offset=0., amp=1., period=1.)\n\nTriangle signal generation function for use with stressfunction or strainfunction. offset keyword argument determines start of triangle signal. amp argument determines the height of each triangle pulse. period determines the period of the triangle wave signal. width determines the width of the triangles.\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.frequencyspec","page":"API","title":"RHEOS.frequencyspec","text":"frequencyspec(r::R; logscale=true)\n\nGenerate RheoFreqData struct with only the frequency data distributed on a linear or log scale.\n\nArguments\n\nr: range, e.g. 1:0.1:100\nlogscale: if true, set the range in logscale, e.g. -2:0.1:20  –> 10 values per decade between 10^-2 and 10^2\n\n\n\n\n\nfrequencyspec(;ω_start::Real, ω_end::Real, logstep::Real= 0.05)\n\nGenerate RheoFreqData struct with only the frequency data distributed on a log scale.\n\nArguments\n\nω_start: min frequency\nω_end: max frequency\nlogstep: step between frequencies in log scale, e.g. 0.1 –> 10 values per decade.\n\n\n\n\n\n","category":"function"},{"location":"API/#Data-IO","page":"API","title":"Data IO","text":"","category":"section"},{"location":"API/","page":"API","title":"API","text":"importcsv\nexportcsv","category":"page"},{"location":"API/#RHEOS.importcsv","page":"API","title":"RHEOS.importcsv","text":"importcsv(filepath::String; delimiter=',', header=false, comment = \"Imported from csv file\", savelog = true, kwargs...)\n\nLoad data from a CSV file (two/three columns, comma separated by default but delimiter can be specified in the delimiter keyword argument). \n\nThe function can be used to construct either a RheoTimeData instance or a RheoFreqData instance, depending on the parameters provided or column names;the function detects whether time or frequency has been included and proceeds accordingly. For oscillatory data, all three columns (Gp, Gpp, Frequency) must be provided. For regular viscoelastic data only time, or time-stress, or time-strain or time-stress-strain data can be provided.\n\nColumn can be specified in the csv file by providing their values or header name (case insensitive) as keyword parameters. \n\nimportcsv(\"filename.csv\", time=1, strain=2, stress=3) loads a RheoTimeData from a csv file with time in the first column, strain in the second, and stress in the third.\n\nimportcsv(\"filename.csv\", omega=\"Frequency\", Gp=\"Storage\", Gpp=\"Loss\") would detect the column numbers by reading the headers on the csv file.\n\nIf no information is provided, it would try to detect columns from header names, expecting standard names. Some of the recognised keywords are time, stress, strain, frequency, storage modulus, loss modulus.\n\nIf the csv file contains headers, but it is prefered to indicate columns by their numbers rather than header strings, the keyword header must be set to true.\n\n\n\n\n\nimportcsv(filepath::String, interface::Interface; delimiter = ',', header = false, comment = \"Imported from csv file\", savelog = true, kwargs...)\n\nImport function for raw data to be transformed to stress and strain using an Interface. Column numbers in the csv containging the force/displacement data need to be indicated as keyword arguments using the corresponding symbols in the interface..\n\nExamples\n\njulia> importcsv(\"myfile.csv\", AFM(2e-6), t=1, d=2, f=3)\n\n\n\n\n\n","category":"function"},{"location":"API/#RHEOS.exportcsv","page":"API","title":"RHEOS.exportcsv","text":"exportcsv(self::Union{RheoTimeData, RheoFreqData}, filedir::String; delimiter=',', colorder=nothing)\n\nExport RheoTimeData or RheoFreqData type to csv format. May be useful for plotting/analysis in other software. By default, full time data will be exported with columns ordered as (t, σ, ϵ). Partial time data will be ordered as either (t, σ) or (t, ϵ). Full frequency data will be ordered as (ω, Gp, Gpp). The order of columns can be customised by passing a NamedTuple to the colorder arguments. For example (σ = 1, t = 3, ϵ = 2) would export the columns in the order (σ, ϵ, t). As with importcsv, the delimiter can be set by keyword argument.\n\n\n\n\n\n","category":"function"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/examples.jl\"","category":"page"},{"location":"examples/#Additional-Examples","page":"Additional Examples","title":"Additional Examples","text":"","category":"section"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"(Image: ) (Image: )","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"using RHEOS","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"PyPlot needs to be installed to run these examples and display plots of the data.","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"using PyPlot","category":"page"},{"location":"examples/#Example-1","page":"Additional Examples","title":"Example 1","text":"","category":"section"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"Loading experimental data from a .csv file\nFitting a model\nCompare original data with fitted model prediction","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"# Make sure the examples folder is the current directory\n# check by typing \"pwd()\"\n\n# Import data\ndata = importcsv(\"assets/example1_data.csv\", t_col = 1, ϵ_col = 2, σ_col = 3)\n\n# Plot data\nfig, ax = subplots(1, 1, figsize = (7, 5))\nax.plot(data.t, data.σ, \".\", color = \"green\")\nax.plot(data.t, data.ϵ, \"-\", color = \"blue\")\nax.set_ylabel(\"Strain (blue), Stress (green)\")\nax.set_xlabel(\"Time\")\nfig #hide","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"# We now fit a Maxwell model\nmaxwell_model = modelfit(data, Maxwell, strain_imposed)","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"Note that the fitting function requires guidance regarding the type of testing used. It helps optimise the fitting process.","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"The data in this example is the stress response to a strain ramp followed by plateau. It therefore corresponds to a strain imposed process.","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"We now want to calculate the stress values predicted by the model given the experimental strain data. Let's create a new data set with the strain profile.","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"maxwell_predict = onlystrain(data)\n# and calculate the stress based on the model\nmaxwell_predict = modelpredict(maxwell_predict, maxwell_model)\n# Now we can plot data and model together for comparison\n\n# Plot data\nfig, ax = subplots(1, 1, figsize = (7, 5))\nax.plot(data.t, data.σ, \".\", color = \"green\")\nax.plot(maxwell_predict.t, maxwell_predict.σ, color = \"red\")\nax.set_xlabel(\"Time\")\nax.set_ylabel(\"Stress\")\nfig #hide","category":"page"},{"location":"examples/#Example-2","page":"Additional Examples","title":"Example 2","text":"","category":"section"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"This script is a slight modification of Example 1 to present to the user the possibility of creating new RheoModelClass from an existing one with some of the parameters frozen to specific values. As an example, we fix the spring constant of the model above (k) to 2 and we let RHEOS fit the viscosity η.","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"Maxwell_springFix = freeze_params(Maxwell, k = 2)","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"maxwellD_model = modelfit(data, Maxwell_springFix, strain_imposed)\nmaxwellD_predict = onlystrain(data)\n# and calculate the stress based on the model\nmaxwellD_predict = modelpredict(maxwellD_predict, maxwellD_model)\n# Now we can plot data and model together for comparison\n\n# Plot data\nfig, ax = subplots(1, 1, figsize = (7, 5))\nax.plot(data.t, data.σ, \".\", color = \"green\")\nax.plot(maxwellD_predict.t, maxwellD_predict.σ, color = \"red\")\nax.set_xlabel(\"Time\")\nax.set_ylabel(\"Stress\")\nfig #hide","category":"page"},{"location":"examples/#Example-3","page":"Additional Examples","title":"Example 3","text":"","category":"section"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"This script shows how to use RHEOS to explore the behaviour of various models This involves:","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"Creating a strain function\nDefining models based on parameter values","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"PyPlot needs to be installed to run these examples and display plots of the data.","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"# Creates a time only dataset\ndϵ = timeline(t_end = 10)\n# calculates strain data by applying a function of time\ndϵ = strainfunction(dϵ, t -> sin(t))\n\n# Plot strain data\nfig, ax = subplots(1, 1, figsize = (7, 5))\nax.plot(dϵ.t, dϵ.ϵ, \"--b\")\n\n# we can now simulate various models based on this strain only dataset\n# Let's study the role of the dashpot strength in the MAxwell model\nfor η in [0.1, 0.3, 1, 3, 10]\n    maxwell_model = RheoModel(Maxwell, k = 2., η = η)\n    d_maxwell = modelpredict(dϵ, maxwell_model)\n    ax.plot(d_maxwell.t, d_maxwell.σ)\nend\nax.set_xlabel(\"Time\")\nax.set_ylabel(\"Stress\")\nax.grid(\"on\")\nfig #hide","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"","category":"page"},{"location":"examples/","page":"Additional Examples","title":"Additional Examples","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#RHEOS-RHEology,-Open-Source","page":"Home","title":"RHEOS - RHEology, Open-Source","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Tests Documentation Coverage Paper\n(Image: Build Status) (Image: Build Status) (Image: Stable Documentation) (Image: Development Documentation) (Image: Code Coverage) (Image: status)","category":"page"},{"location":"","page":"Home","title":"Home","text":"RHEOS, an abbreviation of Rheology Open Source, is a software package written in the Julia programming language that provides tools for analyzing rheological data. Features include:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Stress/Strain/Time data can be easily be fitted to a viscoelastic model\nG'/G''/Frequency data can easily be fitted to a viscoelastic model\nMany standard and fractional viscoelastic models have already been implemented within RHEOS new ones can easily be added by users\nA fitted model can be used to predict the behaviour of the material under other loading conditions, enabling the fit/predict paradigm of model selection\nArtificial loading conditions can be generated within RHEOS to better understand a model's response","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can try out RHEOS interactively in your browser using Binder:  (Image: RHEOS Binder)","category":"page"},{"location":"#Statement-of-Need","page":"Home","title":"Statement of Need","text":"","category":"section"},{"location":"#Arbitrary-stress-strain-curves-and-broad-relaxation-spectra-require-advanced-software","page":"Home","title":"Arbitrary stress-strain curves and broad relaxation spectra require advanced software","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A large majority of scientists and engineers who undertake rheological experiments fit their data with one or several viscoelastic models in order to classify materials, quantify their behaviour and predict their response to external perturbations.","category":"page"},{"location":"#Learning-about-rheology-is-facilitated-by-the-ability-to-explore-a-large-database-of-models","page":"Home","title":"Learning about rheology is facilitated by the ability to explore a large database of models","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Obtaining intuition for fractional viscoelastic theory can be difficult and learning material is sparse. Tools are needed to support researchers with their exploration of standard and advanced models and how they behave in response to idealised loading conditions, in particular when analytical expressions are difficult to obtain.","category":"page"},{"location":"#Extracting-parameters-and-comparing-models-and-systems-require-standardised-tools","page":"Home","title":"Extracting parameters and comparing models and systems require standardised tools","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Because understanding of materials is often dependent on summarising their behaviour with a model, one must be able to test and compare a broad range of models to inform model selection and reliably identify material parameters. There are currently very limited options available in the public domain, and most research groups have to invest significant effort developing custom software. An open-source standardised library of models and fitting algorithms would support the rheology research community and make analysis more systematic, transparent and reproducible.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"RHEOS addresses the issues outlined in the Statement of Need in several ways.","category":"page"},{"location":"","page":"Home","title":"Home","text":"As well as being able to fit and predict assuming step loading of stress or strain, RHEOS can handle arbitrary loading for non-singular and singular models, and for constant or variable sample rates.\nRHEOS includes an extensive library of both traditional and fractional viscoelastic models. Although this library will satisfy most users, it is also straightforward to add additional models to RHEOS should they need to.\nFor intuition-building and model exploration, RHEOS includes signal generation features so that common loading patterns (e.g. step, ramp, stairs) can be applied to unfamiliar models.\nAs a convenience to the user, RHEOS also includes easy-to-use CSV importing and exporting functions, as well as a number of preprocessing functions for resampling and smoothing.","category":"page"},{"location":"","page":"Home","title":"Home","text":"All of the above features are linked together in a seamless interface intended to be very approachable for less experienced programmers. The different paradigms of creep, relaxation and oscillatory testing are all accounted for, and models fitted against one type of data can be used to predict against a different type of data. (For instance, fitting against relaxation data and predicting the frequency response spectrum.)","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install the latest version of Julia\nFrom Julia interactive command-line REPL, enter pkg mode by pressing ]\n(Optional) Enable desired Project.toml environment\nRun the command add RHEOS","category":"page"},{"location":"#Documentation","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you installed RHEOS using the instructions above then you will have the latest stable release of RHEOS; to access the documentation for this version click here or the blue docs/stable badge at the top of this README page. To access the latest documentation built directly from the master branch click here or the blue docs/dev badge at the top of this README page. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"The documentation contains numerous examples of how to use RHEOS for common use cases. Each example can be explored interactively, without even downloading Julia or RHEOS, by clicking on the 'launch binder' button at the top of examples pages. Note that whenever you restart your Julia session you will have to reload RHEOS by typing using RHEOS to follow along with the examples in the documentation. To avoid repetition this line is not included in every piece of example code. For comprehensive descriptions of RHEOS types and functions, see the API section of the documentation. Any plotting library can be used but the tutorials within the documentation use the PyPlot Julia package. For corrections or clarifications to the documentation, please note the 'Contributing to RHEOS' section below and create an issue on the GitHub repository.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use RHEOS in your work, please consider citing the following papers as appropriate:","category":"page"},{"location":"","page":"Home","title":"Home","text":"J. L. Kaplan, A. Bonfanti, A. J. Kabla (2019). RHEOS.jl – A Julia Package for Rheology Data Analysis. Journal of Open Source Software, 4(41), 1700, https://doi.org/10.21105/joss.01700\nA. Bonfanti, J. L. Kaplan, G. Charras, A. J. Kabla (2020). Fractional viscoelastic models for power-law materials. Soft Matter, 16, 6002-6020, https://doi.org/10.1039/D0SM00354A","category":"page"},{"location":"#Contributing-to-RHEOS","page":"Home","title":"Contributing to RHEOS","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you believe you have found any bugs or invalid behaviour in RHEOS, please feel free to file an issue on this repository. You can also raise an issue if you feel that any part of the documentation needs clarification, or for any feature requests. Even better than just raising an issue, you could both raise an issue and issue a pull request which fixes that issue.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We generally work using a greatly simplified version of 'git flow'. Small changes and fixes are directly committed or PR'ed in to the master branch, as longs as tests pass. Larger developments are generally made in feature branches and then merged to master via a pull request, once tests are passing. Stable releases are tagged and sent to the Julia central package repository via JuliaRegistrator and TagBot.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that meta-documentation on running tests and building documentation locally is available at the JuliaRheology/RheoHelpDocs repository. Please be aware that RHEOS is released with a 'Contributor Code of Conduct' (CONDUCT.md) and by participating in this project you agree to abide by its terms.","category":"page"},{"location":"#References","page":"Home","title":"References","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"W. N. Findley, J. S. Lai, K. Onaran (1989). Creep and Relaxation of Nonlinear Viscoelastic Materials (with an Introduction to Linear Viscoelasticity), Dover Publications, New York. \nS. G. Johnson. The NLopt nonlinear-optimization package, https://github.com/stevengj/nlopt\nJ. Bezanson, A. Edelman, S. Karpinski, V. B. Shah (2017). Julia: A Fresh Approach to Numerical Computing, SIAM Review, doi: 10.1137/141000671.","category":"page"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl\"","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"EditURL = \"https://github.com/JuliaRheology/RHEOS.jl/blob/master/docs/src/fitpredictTime.jl\"","category":"page"},{"location":"fitpredictTime/#Fitting-and-Predicting-Time-Data","page":"Time data","title":"Fitting and Predicting - Time Data","text":"","category":"section"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"(Image: ) (Image: )","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"A large majority of scientists and engineers who undertake rheological experiments fit their data with one or several viscoelastic models in order to classify materials, quantify their behaviour and predict their response to external perturbations.","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"Standard linear viscoelastic models take the form of an ordinary differential equation between stress σ and strain ϵ. Fitting models and predicting their response in the time domain then requires computing viscoelastic hereditary integrals such as:","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"sigma(t) = int_0^t G(t - tau) fracd epsilon(tau)d tau d tau","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"where G is the relaxation response (stress response to a step in strain) of the material, which can be analytically or numerically defined for each rheological model and its set of rheological parameters. A similar relation exists to calculate the strain from the stress history:","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"epsilon(t) = int_0^t J(t - tau) fracd sigma(tau)d tau d tau","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"where J is the creep modulus of the material. Fitting and predicting behaviour then becomes non-trivial and standardised tools to process are needed.","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"using RHEOS","category":"page"},{"location":"fitpredictTime/#Fitting","page":"Time data","title":"Fitting","text":"","category":"section"},{"location":"fitpredictTime/#Step-1:-Loading-in-Experimental-Data","page":"Time data","title":"Step 1: Loading in Experimental Data","text":"","category":"section"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"RHEOS has a convenient function to import data from CSV files (more information in File I/O section).","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"data = importcsv(\"assets/data_time.csv\", t_col = 1, ϵ_col = 2, σ_col = 3)\nrheotimedatatype(data)","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"The time, strain and stress data are stored into a RheoTimeData struct.","category":"page"},{"location":"fitpredictTime/#Step-2:-Fitting-Models","page":"Time data","title":"Step 2: Fitting Models","text":"","category":"section"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"Let's fit a Maxwell model via its relaxation modulus, G, as our data is from a stress relaxation test, thus the strain is imposed. The first argument is our data, the second argument tells RHEOS which model to fit (RheoModelClass) and the final argument tells RHEOS whether to fit the model using a relaxation modulus (strain imposed) or creep modulus (stress imposed). The function will return a RheoModel object, i.e. a RheoModelClass with fixed values for the parameters.","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"maxwell_model = modelfit(data, Maxwell, strain_imposed)","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"For the fitting process RHEOS relies on the optimistion package NLopt.jl. RHEOS makes use of a local derivative free algorithm, specifically the Tom Rowan's \"Subplex\" algorithm originally introduced in his PhD thesis at The University of Texas at Austin, 1990.","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"Next, we will fit a fractional Maxwell (spring) model (the only difference from the above model is that the dash-pot is replaced by a spring-pot). This time we will also add upper and lower bounds on the model parameters. This is highly recommended for fractional models in particular as values less than 0 or greater than 1 for the spring-pot parameter are unphysical and can cause errors in the Mittag-Leffler function used (more information about the fractional models in review TBA). To facilitate the convergence of the fitting algorithm, it is also suggested to define an initial set of parameters (the function uses 0.5 for all parameters not defined). For initial parameters, lower bounds and upper bounds, it is possible to only specify some of the parameters and the rest will be filled in automatically.","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"# Lower bounds\nLo = (cₐ = 0.0, a = 0.01, k = 0.0)\n# Upper bounds\nHi = (cₐ = Inf, a = 0.99, k = Inf)\n# Initial parameters\nP0 = (cₐ = 0.1, a = 0.2, k = 2.0)\n\nFmaxwell_model = modelfit(data, FractS_Maxwell, strain_imposed, lo = Lo, hi = Hi, p0 = P0)","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"Further optional parameters can be defined in the fitting function, such as the relative tolerance (default parameter of 1e-4) or the finite difference formula to use for the derivative (\"BD\" = Backward Difference (default), \"CD\" = Central Difference). If the user is interested in the model parameters on each optimisation iteration, they can be printed on the terminal by enabling verbose = true.","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"warning: Important\nOften an ideal step loading is assumed, which simplifies the equations in the first section to σ(t) = G(t)ϵ₀ and ϵ(t) = J(t)σ₀. This enables the modulus to be used directly for the fitting, which vastly reduces the computational burden. For this reason, RHEOS provides a dedicated function modelstepfit that requires the same parameters as modelfit. If this assumption is appropriate for the data then fitting can be sped up greatly by use of this function.","category":"page"},{"location":"fitpredictTime/#Predicting","page":"Time data","title":"Predicting","text":"","category":"section"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"RHEOS allows the user to simulate the response of a model (with defined parameters, RheoModel struct) to an imposed loading.","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"Given an incomplete data set (time data with only either stress or strain missing) and model with values substituted into parameters (RheoModel), return a new \"complete\" dataset based on the model with the simulated missing variable.","category":"page"},{"location":"fitpredictTime/#Assess-Quality-of-the-Fit","page":"Time data","title":"Assess Quality of the Fit","text":"","category":"section"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"The ability of predicting model's response is first exploited to assess the quality of the fits above. The incomplete RheoTimeData variable is defined by extracting the time and the imposed variable (for the current example, the strain).","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"data_ext = onlystrain(data)\n# alternatively: data_ext = extract(data, 1);\n\nrheotimedatatype(data_ext)","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"For the prediction, RHEOS' function modelpredict requires the incomplete data set and a model with fixed parameters (RheoModel). For the assessment of the fitting quality the RheoModel required is the output of the fitting function.","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"maxwell_predict = modelpredict(data_ext, maxwell_model)\n\n# Now we can plot data and model together for comparison\nusing PyPlot\n\nfig, ax = subplots(1, 1, figsize = (7, 5))\nax.plot(data.t, data.σ, \"o\", markersize = 5)\nax.plot(maxwell_predict.t, maxwell_predict.σ, color = \"red\")\nax.set_xlabel(\"Time\")\nax.set_ylabel(\"Stress\")\nfig #hide","category":"page"},{"location":"fitpredictTime/#Simulate-different-model-behaviours","page":"Time data","title":"Simulate different model behaviours","text":"","category":"section"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"The ability of predicting model's response can be exploited to simulate the behaviour of the model to other external loading conditions. For example, we will explore the response of the fitted model to a creep experiment.","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"First we need to define an incomplete RheoTimeData struct, which can be achieved via the data generation functions provided in RHEOS (see section Generating Data).","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"# Define timeline\ndσ = timeline(t_end = 10)\n# and a step in stress\ndσ = stressfunction(dσ, hstep())\n\n# we can now predict the creep response of the Maxwell model\nmaxwell_creepPredict = modelsteppredict(dσ, maxwell_model)\n\n# Init plot figure\nfig, ax = subplots(1, 1, figsize = (7, 5))\n\n# Visualisation of the imposed loading\nax.plot(maxwell_creepPredict.t, maxwell_creepPredict.σ, \"--\")\n# Visualisation of the simulated response\nax.plot(maxwell_creepPredict.t, maxwell_creepPredict.ϵ)\nax.set_xlabel(\"Time\")\nax.set_ylabel(\"Strain\")\nfig #hide","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"warning: Important\nAs for the fitting procedure, if an ideal step loading is assumed, RHEOS provides a dedicated function modelsteppredict that requires the same parameters as modelpredict which significantly reduces the computation time.","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"Similarly, more complex behaviour can be simulated (such as a stairs loading).","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"# Define timeline\ndσ = timeline(t_end = 10)\n# and a step in stress\ndσ = stressfunction(dσ, stairs())\n\n# we can now predict the stairs response of the Maxwell model\nmaxwell_creepPredict = modelpredict(dσ, maxwell_model)\n# Plotting\nfig, ax = subplots(1, 1, figsize = (7, 5))\nax.plot(maxwell_creepPredict.t, maxwell_creepPredict.σ, \"--\")\nax.plot(maxwell_creepPredict.t, maxwell_creepPredict.ϵ)\nax.set_xlabel(\"Time\")\nax.set_ylabel(\"Strain\")\nfig #hide","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"","category":"page"},{"location":"fitpredictTime/","page":"Time data","title":"Time data","text":"This page was generated using Literate.jl.","category":"page"}]
}
